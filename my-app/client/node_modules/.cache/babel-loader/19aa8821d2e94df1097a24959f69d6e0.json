{"ast":null,"code":"import { GraphQLError } from '../../error/GraphQLError';\nexport function cycleErrorMessage(fragName, spreadNames) {\n  var via = spreadNames.length ? ' via ' + spreadNames.join(', ') : '';\n  return \"Cannot spread fragment \\\"\".concat(fragName, \"\\\" within itself\").concat(via, \".\");\n}\nexport function NoFragmentCycles(context) {\n  // Tracks already visited fragments to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  var visitedFrags = Object.create(null); // Array of AST nodes used to produce meaningful errors\n\n  var spreadPath = []; // Position in the spread path\n\n  var spreadPathIndexByName = Object.create(null);\n  return {\n    OperationDefinition: function OperationDefinition() {\n      return false;\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      detectCycleRecursive(node);\n      return false;\n    }\n  }; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(fragment) {\n    if (visitedFrags[fragment.name.value]) {\n      return;\n    }\n    var fragmentName = fragment.name.value;\n    visitedFrags[fragmentName] = true;\n    var spreadNodes = context.getFragmentSpreads(fragment.selectionSet);\n    if (spreadNodes.length === 0) {\n      return;\n    }\n    spreadPathIndexByName[fragmentName] = spreadPath.length;\n    for (var _i2 = 0; _i2 < spreadNodes.length; _i2++) {\n      var spreadNode = spreadNodes[_i2];\n      var spreadName = spreadNode.name.value;\n      var cycleIndex = spreadPathIndexByName[spreadName];\n      spreadPath.push(spreadNode);\n      if (cycleIndex === undefined) {\n        var spreadFragment = context.getFragment(spreadName);\n        if (spreadFragment) {\n          detectCycleRecursive(spreadFragment);\n        }\n      } else {\n        var cyclePath = spreadPath.slice(cycleIndex);\n        var fragmentNames = cyclePath.slice(0, -1).map(function (s) {\n          return s.name.value;\n        });\n        context.reportError(new GraphQLError(cycleErrorMessage(spreadName, fragmentNames), cyclePath));\n      }\n      spreadPath.pop();\n    }\n    spreadPathIndexByName[fragmentName] = undefined;\n  }\n}","map":{"version":3,"names":["GraphQLError","cycleErrorMessage","fragName","spreadNames","via","length","join","concat","NoFragmentCycles","context","visitedFrags","Object","create","spreadPath","spreadPathIndexByName","OperationDefinition","FragmentDefinition","node","detectCycleRecursive","fragment","name","value","fragmentName","spreadNodes","getFragmentSpreads","selectionSet","_i2","spreadNode","spreadName","cycleIndex","push","undefined","spreadFragment","getFragment","cyclePath","slice","fragmentNames","map","s","reportError","pop"],"sources":["/Users/sviatoslav/Documents/Project3/Timekeeper/my-app/client/node_modules/graphql/validation/rules/NoFragmentCycles.mjs"],"sourcesContent":["import { GraphQLError } from '../../error/GraphQLError';\nexport function cycleErrorMessage(fragName, spreadNames) {\n  var via = spreadNames.length ? ' via ' + spreadNames.join(', ') : '';\n  return \"Cannot spread fragment \\\"\".concat(fragName, \"\\\" within itself\").concat(via, \".\");\n}\nexport function NoFragmentCycles(context) {\n  // Tracks already visited fragments to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  var visitedFrags = Object.create(null); // Array of AST nodes used to produce meaningful errors\n\n  var spreadPath = []; // Position in the spread path\n\n  var spreadPathIndexByName = Object.create(null);\n  return {\n    OperationDefinition: function OperationDefinition() {\n      return false;\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      detectCycleRecursive(node);\n      return false;\n    }\n  }; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(fragment) {\n    if (visitedFrags[fragment.name.value]) {\n      return;\n    }\n\n    var fragmentName = fragment.name.value;\n    visitedFrags[fragmentName] = true;\n    var spreadNodes = context.getFragmentSpreads(fragment.selectionSet);\n\n    if (spreadNodes.length === 0) {\n      return;\n    }\n\n    spreadPathIndexByName[fragmentName] = spreadPath.length;\n\n    for (var _i2 = 0; _i2 < spreadNodes.length; _i2++) {\n      var spreadNode = spreadNodes[_i2];\n      var spreadName = spreadNode.name.value;\n      var cycleIndex = spreadPathIndexByName[spreadName];\n      spreadPath.push(spreadNode);\n\n      if (cycleIndex === undefined) {\n        var spreadFragment = context.getFragment(spreadName);\n\n        if (spreadFragment) {\n          detectCycleRecursive(spreadFragment);\n        }\n      } else {\n        var cyclePath = spreadPath.slice(cycleIndex);\n        var fragmentNames = cyclePath.slice(0, -1).map(function (s) {\n          return s.name.value;\n        });\n        context.reportError(new GraphQLError(cycleErrorMessage(spreadName, fragmentNames), cyclePath));\n      }\n\n      spreadPath.pop();\n    }\n\n    spreadPathIndexByName[fragmentName] = undefined;\n  }\n}\n"],"mappings":"AAAA,SAASA,YAAY,QAAQ,0BAA0B;AACvD,OAAO,SAASC,iBAAiBA,CAACC,QAAQ,EAAEC,WAAW,EAAE;EACvD,IAAIC,GAAG,GAAGD,WAAW,CAACE,MAAM,GAAG,OAAO,GAAGF,WAAW,CAACG,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE;EACpE,OAAO,2BAA2B,CAACC,MAAM,CAACL,QAAQ,EAAE,kBAAkB,CAAC,CAACK,MAAM,CAACH,GAAG,EAAE,GAAG,CAAC;AAC1F;AACA,OAAO,SAASI,gBAAgBA,CAACC,OAAO,EAAE;EACxC;EACA;EACA,IAAIC,YAAY,GAAGC,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;;EAExC,IAAIC,UAAU,GAAG,EAAE,CAAC,CAAC;;EAErB,IAAIC,qBAAqB,GAAGH,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC;EAC/C,OAAO;IACLG,mBAAmB,EAAE,SAASA,mBAAmBA,CAAA,EAAG;MAClD,OAAO,KAAK;IACd,CAAC;IACDC,kBAAkB,EAAE,SAASA,kBAAkBA,CAACC,IAAI,EAAE;MACpDC,oBAAoB,CAACD,IAAI,CAAC;MAC1B,OAAO,KAAK;IACd;EACF,CAAC,CAAC,CAAC;EACH;EACA;;EAEA,SAASC,oBAAoBA,CAACC,QAAQ,EAAE;IACtC,IAAIT,YAAY,CAACS,QAAQ,CAACC,IAAI,CAACC,KAAK,CAAC,EAAE;MACrC;IACF;IAEA,IAAIC,YAAY,GAAGH,QAAQ,CAACC,IAAI,CAACC,KAAK;IACtCX,YAAY,CAACY,YAAY,CAAC,GAAG,IAAI;IACjC,IAAIC,WAAW,GAAGd,OAAO,CAACe,kBAAkB,CAACL,QAAQ,CAACM,YAAY,CAAC;IAEnE,IAAIF,WAAW,CAAClB,MAAM,KAAK,CAAC,EAAE;MAC5B;IACF;IAEAS,qBAAqB,CAACQ,YAAY,CAAC,GAAGT,UAAU,CAACR,MAAM;IAEvD,KAAK,IAAIqB,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGH,WAAW,CAAClB,MAAM,EAAEqB,GAAG,EAAE,EAAE;MACjD,IAAIC,UAAU,GAAGJ,WAAW,CAACG,GAAG,CAAC;MACjC,IAAIE,UAAU,GAAGD,UAAU,CAACP,IAAI,CAACC,KAAK;MACtC,IAAIQ,UAAU,GAAGf,qBAAqB,CAACc,UAAU,CAAC;MAClDf,UAAU,CAACiB,IAAI,CAACH,UAAU,CAAC;MAE3B,IAAIE,UAAU,KAAKE,SAAS,EAAE;QAC5B,IAAIC,cAAc,GAAGvB,OAAO,CAACwB,WAAW,CAACL,UAAU,CAAC;QAEpD,IAAII,cAAc,EAAE;UAClBd,oBAAoB,CAACc,cAAc,CAAC;QACtC;MACF,CAAC,MAAM;QACL,IAAIE,SAAS,GAAGrB,UAAU,CAACsB,KAAK,CAACN,UAAU,CAAC;QAC5C,IAAIO,aAAa,GAAGF,SAAS,CAACC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAACE,GAAG,CAAC,UAAUC,CAAC,EAAE;UAC1D,OAAOA,CAAC,CAAClB,IAAI,CAACC,KAAK;QACrB,CAAC,CAAC;QACFZ,OAAO,CAAC8B,WAAW,CAAC,IAAIvC,YAAY,CAACC,iBAAiB,CAAC2B,UAAU,EAAEQ,aAAa,CAAC,EAAEF,SAAS,CAAC,CAAC;MAChG;MAEArB,UAAU,CAAC2B,GAAG,CAAC,CAAC;IAClB;IAEA1B,qBAAqB,CAACQ,YAAY,CAAC,GAAGS,SAAS;EACjD;AACF"},"metadata":{},"sourceType":"module"}