{"ast":null,"code":"import didYouMean from '../../jsutils/didYouMean';\nimport suggestionList from '../../jsutils/suggestionList';\nimport { GraphQLError } from '../../error/GraphQLError';\nimport { isTypeDefinitionNode, isTypeSystemDefinitionNode, isTypeSystemExtensionNode } from '../../language/predicates';\nimport { specifiedScalarTypes } from '../../type/scalars';\nexport function unknownTypeMessage(typeName, suggestedTypes) {\n  return \"Unknown type \\\"\".concat(typeName, \"\\\".\") + didYouMean(suggestedTypes.map(function (x) {\n    return \"\\\"\".concat(x, \"\\\"\");\n  }));\n}\n/**\n * Known type names\n *\n * A GraphQL document is only valid if referenced types (specifically\n * variable definitions and fragment conditions) are defined by the type schema.\n */\n\nexport function KnownTypeNames(context) {\n  var schema = context.getSchema();\n  var existingTypesMap = schema ? schema.getTypeMap() : Object.create(null);\n  var definedTypes = Object.create(null);\n  for (var _i2 = 0, _context$getDocument$2 = context.getDocument().definitions; _i2 < _context$getDocument$2.length; _i2++) {\n    var def = _context$getDocument$2[_i2];\n    if (isTypeDefinitionNode(def)) {\n      definedTypes[def.name.value] = true;\n    }\n  }\n  var typeNames = Object.keys(existingTypesMap).concat(Object.keys(definedTypes));\n  return {\n    NamedType: function NamedType(node, _1, parent, _2, ancestors) {\n      var typeName = node.name.value;\n      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {\n        var definitionNode = ancestors[2] || parent;\n        var isSDL = isSDLNode(definitionNode);\n        if (isSDL && isSpecifiedScalarName(typeName)) {\n          return;\n        }\n        var suggestedTypes = suggestionList(typeName, isSDL ? specifiedScalarsNames.concat(typeNames) : typeNames);\n        context.reportError(new GraphQLError(unknownTypeMessage(typeName, suggestedTypes), node));\n      }\n    }\n  };\n}\nvar specifiedScalarsNames = specifiedScalarTypes.map(function (type) {\n  return type.name;\n});\nfunction isSpecifiedScalarName(typeName) {\n  return specifiedScalarsNames.indexOf(typeName) !== -1;\n}\nfunction isSDLNode(value) {\n  return Boolean(value && !Array.isArray(value) && (isTypeSystemDefinitionNode(value) || isTypeSystemExtensionNode(value)));\n}","map":{"version":3,"names":["didYouMean","suggestionList","GraphQLError","isTypeDefinitionNode","isTypeSystemDefinitionNode","isTypeSystemExtensionNode","specifiedScalarTypes","unknownTypeMessage","typeName","suggestedTypes","concat","map","x","KnownTypeNames","context","schema","getSchema","existingTypesMap","getTypeMap","Object","create","definedTypes","_i2","_context$getDocument$2","getDocument","definitions","length","def","name","value","typeNames","keys","NamedType","node","_1","parent","_2","ancestors","definitionNode","isSDL","isSDLNode","isSpecifiedScalarName","specifiedScalarsNames","reportError","type","indexOf","Boolean","Array","isArray"],"sources":["/Users/sviatoslav/Documents/Project3/Timekeeper/my-app/client/node_modules/graphql/validation/rules/KnownTypeNames.mjs"],"sourcesContent":["import didYouMean from '../../jsutils/didYouMean';\nimport suggestionList from '../../jsutils/suggestionList';\nimport { GraphQLError } from '../../error/GraphQLError';\nimport { isTypeDefinitionNode, isTypeSystemDefinitionNode, isTypeSystemExtensionNode } from '../../language/predicates';\nimport { specifiedScalarTypes } from '../../type/scalars';\nexport function unknownTypeMessage(typeName, suggestedTypes) {\n  return \"Unknown type \\\"\".concat(typeName, \"\\\".\") + didYouMean(suggestedTypes.map(function (x) {\n    return \"\\\"\".concat(x, \"\\\"\");\n  }));\n}\n/**\n * Known type names\n *\n * A GraphQL document is only valid if referenced types (specifically\n * variable definitions and fragment conditions) are defined by the type schema.\n */\n\nexport function KnownTypeNames(context) {\n  var schema = context.getSchema();\n  var existingTypesMap = schema ? schema.getTypeMap() : Object.create(null);\n  var definedTypes = Object.create(null);\n\n  for (var _i2 = 0, _context$getDocument$2 = context.getDocument().definitions; _i2 < _context$getDocument$2.length; _i2++) {\n    var def = _context$getDocument$2[_i2];\n\n    if (isTypeDefinitionNode(def)) {\n      definedTypes[def.name.value] = true;\n    }\n  }\n\n  var typeNames = Object.keys(existingTypesMap).concat(Object.keys(definedTypes));\n  return {\n    NamedType: function NamedType(node, _1, parent, _2, ancestors) {\n      var typeName = node.name.value;\n\n      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {\n        var definitionNode = ancestors[2] || parent;\n        var isSDL = isSDLNode(definitionNode);\n\n        if (isSDL && isSpecifiedScalarName(typeName)) {\n          return;\n        }\n\n        var suggestedTypes = suggestionList(typeName, isSDL ? specifiedScalarsNames.concat(typeNames) : typeNames);\n        context.reportError(new GraphQLError(unknownTypeMessage(typeName, suggestedTypes), node));\n      }\n    }\n  };\n}\nvar specifiedScalarsNames = specifiedScalarTypes.map(function (type) {\n  return type.name;\n});\n\nfunction isSpecifiedScalarName(typeName) {\n  return specifiedScalarsNames.indexOf(typeName) !== -1;\n}\n\nfunction isSDLNode(value) {\n  return Boolean(value && !Array.isArray(value) && (isTypeSystemDefinitionNode(value) || isTypeSystemExtensionNode(value)));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}