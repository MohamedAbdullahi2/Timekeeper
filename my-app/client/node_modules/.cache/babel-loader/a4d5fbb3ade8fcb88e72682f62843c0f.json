{"ast":null,"code":"import { forEach, isCollection } from 'iterall';\nimport objectValues from '../polyfills/objectValues';\nimport inspect from '../jsutils/inspect';\nimport invariant from '../jsutils/invariant';\nimport isNullish from '../jsutils/isNullish';\nimport isInvalid from '../jsutils/isInvalid';\nimport isObjectLike from '../jsutils/isObjectLike';\nimport { Kind } from '../language/kinds';\nimport { GraphQLID } from '../type/scalars';\nimport { isLeafType, isEnumType, isInputObjectType, isListType, isNonNullType } from '../type/definition';\n/**\n * Produces a GraphQL Value AST given a JavaScript value.\n *\n * A GraphQL type must be provided, which will be used to interpret different\n * JavaScript values.\n *\n * | JSON Value    | GraphQL Value        |\n * | ------------- | -------------------- |\n * | Object        | Input Object         |\n * | Array         | List                 |\n * | Boolean       | Boolean              |\n * | String        | String / Enum Value  |\n * | Number        | Int / Float          |\n * | Mixed         | Enum Value           |\n * | null          | NullValue            |\n *\n */\n\nexport function astFromValue(value, type) {\n  if (isNonNullType(type)) {\n    var astValue = astFromValue(value, type.ofType);\n    if (astValue && astValue.kind === Kind.NULL) {\n      return null;\n    }\n    return astValue;\n  } // only explicit null, not undefined, NaN\n\n  if (value === null) {\n    return {\n      kind: Kind.NULL\n    };\n  } // undefined, NaN\n\n  if (isInvalid(value)) {\n    return null;\n  } // Convert JavaScript array to GraphQL list. If the GraphQLType is a list, but\n  // the value is not an array, convert the value using the list's item type.\n\n  if (isListType(type)) {\n    var itemType = type.ofType;\n    if (isCollection(value)) {\n      var valuesNodes = [];\n      forEach(value, function (item) {\n        var itemNode = astFromValue(item, itemType);\n        if (itemNode) {\n          valuesNodes.push(itemNode);\n        }\n      });\n      return {\n        kind: Kind.LIST,\n        values: valuesNodes\n      };\n    }\n    return astFromValue(value, itemType);\n  } // Populate the fields of the input object by creating ASTs from each value\n  // in the JavaScript object according to the fields in the input type.\n\n  if (isInputObjectType(type)) {\n    if (!isObjectLike(value)) {\n      return null;\n    }\n    var fieldNodes = [];\n    for (var _i2 = 0, _objectValues2 = objectValues(type.getFields()); _i2 < _objectValues2.length; _i2++) {\n      var field = _objectValues2[_i2];\n      var fieldValue = astFromValue(value[field.name], field.type);\n      if (fieldValue) {\n        fieldNodes.push({\n          kind: Kind.OBJECT_FIELD,\n          name: {\n            kind: Kind.NAME,\n            value: field.name\n          },\n          value: fieldValue\n        });\n      }\n    }\n    return {\n      kind: Kind.OBJECT,\n      fields: fieldNodes\n    };\n  }\n\n  /* istanbul ignore else */\n  if (isLeafType(type)) {\n    // Since value is an internally represented value, it must be serialized\n    // to an externally represented value before converting into an AST.\n    var serialized = type.serialize(value);\n    if (isNullish(serialized)) {\n      return null;\n    } // Others serialize based on their corresponding JavaScript scalar types.\n\n    if (typeof serialized === 'boolean') {\n      return {\n        kind: Kind.BOOLEAN,\n        value: serialized\n      };\n    } // JavaScript numbers can be Int or Float values.\n\n    if (typeof serialized === 'number') {\n      var stringNum = String(serialized);\n      return integerStringRegExp.test(stringNum) ? {\n        kind: Kind.INT,\n        value: stringNum\n      } : {\n        kind: Kind.FLOAT,\n        value: stringNum\n      };\n    }\n    if (typeof serialized === 'string') {\n      // Enum types use Enum literals.\n      if (isEnumType(type)) {\n        return {\n          kind: Kind.ENUM,\n          value: serialized\n        };\n      } // ID types can use Int literals.\n\n      if (type === GraphQLID && integerStringRegExp.test(serialized)) {\n        return {\n          kind: Kind.INT,\n          value: serialized\n        };\n      }\n      return {\n        kind: Kind.STRING,\n        value: serialized\n      };\n    }\n    throw new TypeError(\"Cannot convert value to AST: \".concat(inspect(serialized)));\n  } // Not reachable. All possible input types have been considered.\n\n  /* istanbul ignore next */\n  invariant(false, 'Unexpected input type: ' + inspect(type));\n}\n/**\n * IntValue:\n *   - NegativeSign? 0\n *   - NegativeSign? NonZeroDigit ( Digit+ )?\n */\n\nvar integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;","map":{"version":3,"names":["forEach","isCollection","objectValues","inspect","invariant","isNullish","isInvalid","isObjectLike","Kind","GraphQLID","isLeafType","isEnumType","isInputObjectType","isListType","isNonNullType","astFromValue","value","type","astValue","ofType","kind","NULL","itemType","valuesNodes","item","itemNode","push","LIST","values","fieldNodes","_i2","_objectValues2","getFields","length","field","fieldValue","name","OBJECT_FIELD","NAME","OBJECT","fields","serialized","serialize","BOOLEAN","stringNum","String","integerStringRegExp","test","INT","FLOAT","ENUM","STRING","TypeError","concat"],"sources":["/Users/sviatoslav/Documents/Project3/Timekeeper/my-app/client/node_modules/graphql/utilities/astFromValue.mjs"],"sourcesContent":["import { forEach, isCollection } from 'iterall';\nimport objectValues from '../polyfills/objectValues';\nimport inspect from '../jsutils/inspect';\nimport invariant from '../jsutils/invariant';\nimport isNullish from '../jsutils/isNullish';\nimport isInvalid from '../jsutils/isInvalid';\nimport isObjectLike from '../jsutils/isObjectLike';\nimport { Kind } from '../language/kinds';\nimport { GraphQLID } from '../type/scalars';\nimport { isLeafType, isEnumType, isInputObjectType, isListType, isNonNullType } from '../type/definition';\n/**\n * Produces a GraphQL Value AST given a JavaScript value.\n *\n * A GraphQL type must be provided, which will be used to interpret different\n * JavaScript values.\n *\n * | JSON Value    | GraphQL Value        |\n * | ------------- | -------------------- |\n * | Object        | Input Object         |\n * | Array         | List                 |\n * | Boolean       | Boolean              |\n * | String        | String / Enum Value  |\n * | Number        | Int / Float          |\n * | Mixed         | Enum Value           |\n * | null          | NullValue            |\n *\n */\n\nexport function astFromValue(value, type) {\n  if (isNonNullType(type)) {\n    var astValue = astFromValue(value, type.ofType);\n\n    if (astValue && astValue.kind === Kind.NULL) {\n      return null;\n    }\n\n    return astValue;\n  } // only explicit null, not undefined, NaN\n\n\n  if (value === null) {\n    return {\n      kind: Kind.NULL\n    };\n  } // undefined, NaN\n\n\n  if (isInvalid(value)) {\n    return null;\n  } // Convert JavaScript array to GraphQL list. If the GraphQLType is a list, but\n  // the value is not an array, convert the value using the list's item type.\n\n\n  if (isListType(type)) {\n    var itemType = type.ofType;\n\n    if (isCollection(value)) {\n      var valuesNodes = [];\n      forEach(value, function (item) {\n        var itemNode = astFromValue(item, itemType);\n\n        if (itemNode) {\n          valuesNodes.push(itemNode);\n        }\n      });\n      return {\n        kind: Kind.LIST,\n        values: valuesNodes\n      };\n    }\n\n    return astFromValue(value, itemType);\n  } // Populate the fields of the input object by creating ASTs from each value\n  // in the JavaScript object according to the fields in the input type.\n\n\n  if (isInputObjectType(type)) {\n    if (!isObjectLike(value)) {\n      return null;\n    }\n\n    var fieldNodes = [];\n\n    for (var _i2 = 0, _objectValues2 = objectValues(type.getFields()); _i2 < _objectValues2.length; _i2++) {\n      var field = _objectValues2[_i2];\n      var fieldValue = astFromValue(value[field.name], field.type);\n\n      if (fieldValue) {\n        fieldNodes.push({\n          kind: Kind.OBJECT_FIELD,\n          name: {\n            kind: Kind.NAME,\n            value: field.name\n          },\n          value: fieldValue\n        });\n      }\n    }\n\n    return {\n      kind: Kind.OBJECT,\n      fields: fieldNodes\n    };\n  }\n\n  /* istanbul ignore else */\n  if (isLeafType(type)) {\n    // Since value is an internally represented value, it must be serialized\n    // to an externally represented value before converting into an AST.\n    var serialized = type.serialize(value);\n\n    if (isNullish(serialized)) {\n      return null;\n    } // Others serialize based on their corresponding JavaScript scalar types.\n\n\n    if (typeof serialized === 'boolean') {\n      return {\n        kind: Kind.BOOLEAN,\n        value: serialized\n      };\n    } // JavaScript numbers can be Int or Float values.\n\n\n    if (typeof serialized === 'number') {\n      var stringNum = String(serialized);\n      return integerStringRegExp.test(stringNum) ? {\n        kind: Kind.INT,\n        value: stringNum\n      } : {\n        kind: Kind.FLOAT,\n        value: stringNum\n      };\n    }\n\n    if (typeof serialized === 'string') {\n      // Enum types use Enum literals.\n      if (isEnumType(type)) {\n        return {\n          kind: Kind.ENUM,\n          value: serialized\n        };\n      } // ID types can use Int literals.\n\n\n      if (type === GraphQLID && integerStringRegExp.test(serialized)) {\n        return {\n          kind: Kind.INT,\n          value: serialized\n        };\n      }\n\n      return {\n        kind: Kind.STRING,\n        value: serialized\n      };\n    }\n\n    throw new TypeError(\"Cannot convert value to AST: \".concat(inspect(serialized)));\n  } // Not reachable. All possible input types have been considered.\n\n\n  /* istanbul ignore next */\n  invariant(false, 'Unexpected input type: ' + inspect(type));\n}\n/**\n * IntValue:\n *   - NegativeSign? 0\n *   - NegativeSign? NonZeroDigit ( Digit+ )?\n */\n\nvar integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}