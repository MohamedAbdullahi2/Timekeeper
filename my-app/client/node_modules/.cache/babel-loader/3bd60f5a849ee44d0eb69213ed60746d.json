{"ast":null,"code":"import { GraphQLError } from '../../error/GraphQLError';\nimport { Kind } from '../../language/kinds';\nimport { specifiedDirectives } from '../../type/directives';\nexport function duplicateDirectiveMessage(directiveName) {\n  return \"The directive \\\"\".concat(directiveName, \"\\\" can only be used once at this location.\");\n}\n/**\n * Unique directive names per location\n *\n * A GraphQL document is only valid if all non-repeatable directives at\n * a given location are uniquely named.\n */\n\nexport function UniqueDirectivesPerLocation(context) {\n  var uniqueDirectiveMap = Object.create(null);\n  var schema = context.getSchema();\n  var definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;\n  for (var _i2 = 0; _i2 < definedDirectives.length; _i2++) {\n    var directive = definedDirectives[_i2];\n    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;\n  }\n  var astDefinitions = context.getDocument().definitions;\n  for (var _i4 = 0; _i4 < astDefinitions.length; _i4++) {\n    var def = astDefinitions[_i4];\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      uniqueDirectiveMap[def.name.value] = !def.repeatable;\n    }\n  }\n  return {\n    // Many different AST nodes may contain directives. Rather than listing\n    // them all, just listen for entering any node, and check to see if it\n    // defines any directives.\n    enter: function enter(node) {\n      // Flow can't refine that node.directives will only contain directives,\n      // so we cast so the rest of the code is well typed.\n      var directives = node.directives;\n      if (directives) {\n        var knownDirectives = Object.create(null);\n        for (var _i6 = 0; _i6 < directives.length; _i6++) {\n          var _directive = directives[_i6];\n          var directiveName = _directive.name.value;\n          if (uniqueDirectiveMap[directiveName]) {\n            if (knownDirectives[directiveName]) {\n              context.reportError(new GraphQLError(duplicateDirectiveMessage(directiveName), [knownDirectives[directiveName], _directive]));\n            } else {\n              knownDirectives[directiveName] = _directive;\n            }\n          }\n        }\n      }\n    }\n  };\n}","map":{"version":3,"names":["GraphQLError","Kind","specifiedDirectives","duplicateDirectiveMessage","directiveName","concat","UniqueDirectivesPerLocation","context","uniqueDirectiveMap","Object","create","schema","getSchema","definedDirectives","getDirectives","_i2","length","directive","name","isRepeatable","astDefinitions","getDocument","definitions","_i4","def","kind","DIRECTIVE_DEFINITION","value","repeatable","enter","node","directives","knownDirectives","_i6","_directive","reportError"],"sources":["/Users/sviatoslav/Documents/Project3/Timekeeper/my-app/client/node_modules/graphql/validation/rules/UniqueDirectivesPerLocation.mjs"],"sourcesContent":["import { GraphQLError } from '../../error/GraphQLError';\nimport { Kind } from '../../language/kinds';\nimport { specifiedDirectives } from '../../type/directives';\nexport function duplicateDirectiveMessage(directiveName) {\n  return \"The directive \\\"\".concat(directiveName, \"\\\" can only be used once at this location.\");\n}\n/**\n * Unique directive names per location\n *\n * A GraphQL document is only valid if all non-repeatable directives at\n * a given location are uniquely named.\n */\n\nexport function UniqueDirectivesPerLocation(context) {\n  var uniqueDirectiveMap = Object.create(null);\n  var schema = context.getSchema();\n  var definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;\n\n  for (var _i2 = 0; _i2 < definedDirectives.length; _i2++) {\n    var directive = definedDirectives[_i2];\n    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;\n  }\n\n  var astDefinitions = context.getDocument().definitions;\n\n  for (var _i4 = 0; _i4 < astDefinitions.length; _i4++) {\n    var def = astDefinitions[_i4];\n\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      uniqueDirectiveMap[def.name.value] = !def.repeatable;\n    }\n  }\n\n  return {\n    // Many different AST nodes may contain directives. Rather than listing\n    // them all, just listen for entering any node, and check to see if it\n    // defines any directives.\n    enter: function enter(node) {\n      // Flow can't refine that node.directives will only contain directives,\n      // so we cast so the rest of the code is well typed.\n      var directives = node.directives;\n\n      if (directives) {\n        var knownDirectives = Object.create(null);\n\n        for (var _i6 = 0; _i6 < directives.length; _i6++) {\n          var _directive = directives[_i6];\n          var directiveName = _directive.name.value;\n\n          if (uniqueDirectiveMap[directiveName]) {\n            if (knownDirectives[directiveName]) {\n              context.reportError(new GraphQLError(duplicateDirectiveMessage(directiveName), [knownDirectives[directiveName], _directive]));\n            } else {\n              knownDirectives[directiveName] = _directive;\n            }\n          }\n        }\n      }\n    }\n  };\n}\n"],"mappings":"AAAA,SAASA,YAAY,QAAQ,0BAA0B;AACvD,SAASC,IAAI,QAAQ,sBAAsB;AAC3C,SAASC,mBAAmB,QAAQ,uBAAuB;AAC3D,OAAO,SAASC,yBAAyBA,CAACC,aAAa,EAAE;EACvD,OAAO,kBAAkB,CAACC,MAAM,CAACD,aAAa,EAAE,4CAA4C,CAAC;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASE,2BAA2BA,CAACC,OAAO,EAAE;EACnD,IAAIC,kBAAkB,GAAGC,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC;EAC5C,IAAIC,MAAM,GAAGJ,OAAO,CAACK,SAAS,CAAC,CAAC;EAChC,IAAIC,iBAAiB,GAAGF,MAAM,GAAGA,MAAM,CAACG,aAAa,CAAC,CAAC,GAAGZ,mBAAmB;EAE7E,KAAK,IAAIa,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGF,iBAAiB,CAACG,MAAM,EAAED,GAAG,EAAE,EAAE;IACvD,IAAIE,SAAS,GAAGJ,iBAAiB,CAACE,GAAG,CAAC;IACtCP,kBAAkB,CAACS,SAAS,CAACC,IAAI,CAAC,GAAG,CAACD,SAAS,CAACE,YAAY;EAC9D;EAEA,IAAIC,cAAc,GAAGb,OAAO,CAACc,WAAW,CAAC,CAAC,CAACC,WAAW;EAEtD,KAAK,IAAIC,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGH,cAAc,CAACJ,MAAM,EAAEO,GAAG,EAAE,EAAE;IACpD,IAAIC,GAAG,GAAGJ,cAAc,CAACG,GAAG,CAAC;IAE7B,IAAIC,GAAG,CAACC,IAAI,KAAKxB,IAAI,CAACyB,oBAAoB,EAAE;MAC1ClB,kBAAkB,CAACgB,GAAG,CAACN,IAAI,CAACS,KAAK,CAAC,GAAG,CAACH,GAAG,CAACI,UAAU;IACtD;EACF;EAEA,OAAO;IACL;IACA;IACA;IACAC,KAAK,EAAE,SAASA,KAAKA,CAACC,IAAI,EAAE;MAC1B;MACA;MACA,IAAIC,UAAU,GAAGD,IAAI,CAACC,UAAU;MAEhC,IAAIA,UAAU,EAAE;QACd,IAAIC,eAAe,GAAGvB,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC;QAEzC,KAAK,IAAIuB,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGF,UAAU,CAACf,MAAM,EAAEiB,GAAG,EAAE,EAAE;UAChD,IAAIC,UAAU,GAAGH,UAAU,CAACE,GAAG,CAAC;UAChC,IAAI7B,aAAa,GAAG8B,UAAU,CAAChB,IAAI,CAACS,KAAK;UAEzC,IAAInB,kBAAkB,CAACJ,aAAa,CAAC,EAAE;YACrC,IAAI4B,eAAe,CAAC5B,aAAa,CAAC,EAAE;cAClCG,OAAO,CAAC4B,WAAW,CAAC,IAAInC,YAAY,CAACG,yBAAyB,CAACC,aAAa,CAAC,EAAE,CAAC4B,eAAe,CAAC5B,aAAa,CAAC,EAAE8B,UAAU,CAAC,CAAC,CAAC;YAC/H,CAAC,MAAM;cACLF,eAAe,CAAC5B,aAAa,CAAC,GAAG8B,UAAU;YAC7C;UACF;QACF;MACF;IACF;EACF,CAAC;AACH"},"metadata":{},"sourceType":"module"}