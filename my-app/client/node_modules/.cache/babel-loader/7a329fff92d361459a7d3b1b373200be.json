{"ast":null,"code":"import find from '../polyfills/find';\nimport flatMap from '../polyfills/flatMap';\nimport objectValues from '../polyfills/objectValues';\nimport objectEntries from '../polyfills/objectEntries';\nimport inspect from '../jsutils/inspect';\nimport { GraphQLError } from '../error/GraphQLError';\nimport { isValidNameError } from '../utilities/assertValidName';\nimport { isEqualType, isTypeSubTypeOf } from '../utilities/typeComparators';\nimport { isDirective } from './directives';\nimport { isIntrospectionType } from './introspection';\nimport { assertSchema } from './schema';\nimport { isObjectType, isInterfaceType, isUnionType, isEnumType, isInputObjectType, isNamedType, isNonNullType, isInputType, isOutputType, isRequiredArgument } from './definition';\n/**\n * Implements the \"Type Validation\" sub-sections of the specification's\n * \"Type System\" section.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the Schema is valid.\n */\n\nexport function validateSchema(schema) {\n  // First check to ensure the provided value is in fact a GraphQLSchema.\n  assertSchema(schema); // If this Schema has already been validated, return the previous results.\n\n  if (schema.__validationErrors) {\n    return schema.__validationErrors;\n  } // Validate the schema, producing a list of errors.\n\n  var context = new SchemaValidationContext(schema);\n  validateRootTypes(context);\n  validateDirectives(context);\n  validateTypes(context); // Persist the results of validation before returning to ensure validation\n  // does not run multiple times for this schema.\n\n  var errors = context.getErrors();\n  schema.__validationErrors = errors;\n  return errors;\n}\n/**\n * Utility function which asserts a schema is valid by throwing an error if\n * it is invalid.\n */\n\nexport function assertValidSchema(schema) {\n  var errors = validateSchema(schema);\n  if (errors.length !== 0) {\n    throw new Error(errors.map(function (error) {\n      return error.message;\n    }).join('\\n\\n'));\n  }\n}\nvar SchemaValidationContext = /*#__PURE__*/\nfunction () {\n  function SchemaValidationContext(schema) {\n    this._errors = [];\n    this.schema = schema;\n  }\n  var _proto = SchemaValidationContext.prototype;\n  _proto.reportError = function reportError(message, nodes) {\n    var _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;\n    this.addError(new GraphQLError(message, _nodes));\n  };\n  _proto.addError = function addError(error) {\n    this._errors.push(error);\n  };\n  _proto.getErrors = function getErrors() {\n    return this._errors;\n  };\n  return SchemaValidationContext;\n}();\nfunction validateRootTypes(context) {\n  var schema = context.schema;\n  var queryType = schema.getQueryType();\n  if (!queryType) {\n    context.reportError('Query root type must be provided.', schema.astNode);\n  } else if (!isObjectType(queryType)) {\n    context.reportError(\"Query root type must be Object type, it cannot be \".concat(inspect(queryType), \".\"), getOperationTypeNode(schema, queryType, 'query'));\n  }\n  var mutationType = schema.getMutationType();\n  if (mutationType && !isObjectType(mutationType)) {\n    context.reportError('Mutation root type must be Object type if provided, it cannot be ' + \"\".concat(inspect(mutationType), \".\"), getOperationTypeNode(schema, mutationType, 'mutation'));\n  }\n  var subscriptionType = schema.getSubscriptionType();\n  if (subscriptionType && !isObjectType(subscriptionType)) {\n    context.reportError('Subscription root type must be Object type if provided, it cannot be ' + \"\".concat(inspect(subscriptionType), \".\"), getOperationTypeNode(schema, subscriptionType, 'subscription'));\n  }\n}\nfunction getOperationTypeNode(schema, type, operation) {\n  var operationNodes = getAllSubNodes(schema, function (node) {\n    return node.operationTypes;\n  });\n  for (var _i2 = 0; _i2 < operationNodes.length; _i2++) {\n    var node = operationNodes[_i2];\n    if (node.operation === operation) {\n      return node.type;\n    }\n  }\n  return type.astNode;\n}\nfunction validateDirectives(context) {\n  for (var _i4 = 0, _context$schema$getDi2 = context.schema.getDirectives(); _i4 < _context$schema$getDi2.length; _i4++) {\n    var directive = _context$schema$getDi2[_i4];\n\n    // Ensure all directives are in fact GraphQL directives.\n    if (!isDirective(directive)) {\n      context.reportError(\"Expected directive but got: \".concat(inspect(directive), \".\"), directive && directive.astNode);\n      continue;\n    } // Ensure they are named correctly.\n\n    validateName(context, directive); // TODO: Ensure proper locations.\n    // Ensure the arguments are valid.\n\n    var argNames = Object.create(null);\n    var _loop = function _loop(_i6, _directive$args2) {\n      var arg = _directive$args2[_i6];\n      var argName = arg.name; // Ensure they are named correctly.\n\n      validateName(context, arg); // Ensure they are unique per directive.\n\n      if (argNames[argName]) {\n        context.reportError(\"Argument @\".concat(directive.name, \"(\").concat(argName, \":) can only be defined once.\"), directive.astNode && directive.args.filter(function (_ref) {\n          var name = _ref.name;\n          return name === argName;\n        }).map(function (_ref2) {\n          var astNode = _ref2.astNode;\n          return astNode;\n        }));\n        return \"continue\";\n      }\n      argNames[argName] = true; // Ensure the type is an input type.\n\n      if (!isInputType(arg.type)) {\n        context.reportError(\"The type of @\".concat(directive.name, \"(\").concat(argName, \":) must be Input Type \") + \"but got: \".concat(inspect(arg.type), \".\"), arg.astNode);\n      }\n    };\n    for (var _i6 = 0, _directive$args2 = directive.args; _i6 < _directive$args2.length; _i6++) {\n      var _ret = _loop(_i6, _directive$args2);\n      if (_ret === \"continue\") continue;\n    }\n  }\n}\nfunction validateName(context, node) {\n  // If a schema explicitly allows some legacy name which is no longer valid,\n  // allow it to be assumed valid.\n  if (context.schema.__allowedLegacyNames.indexOf(node.name) !== -1) {\n    return;\n  } // Ensure names are valid, however introspection types opt out.\n\n  var error = isValidNameError(node.name, node.astNode || undefined);\n  if (error) {\n    context.addError(error);\n  }\n}\nfunction validateTypes(context) {\n  var validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context);\n  var typeMap = context.schema.getTypeMap();\n  for (var _i8 = 0, _objectValues2 = objectValues(typeMap); _i8 < _objectValues2.length; _i8++) {\n    var type = _objectValues2[_i8];\n\n    // Ensure all provided types are in fact GraphQL type.\n    if (!isNamedType(type)) {\n      context.reportError(\"Expected GraphQL named type but got: \".concat(inspect(type), \".\"), type && type.astNode);\n      continue;\n    } // Ensure it is named correctly (excluding introspection types).\n\n    if (!isIntrospectionType(type)) {\n      validateName(context, type);\n    }\n    if (isObjectType(type)) {\n      // Ensure fields are valid\n      validateFields(context, type); // Ensure objects implement the interfaces they claim to.\n\n      validateObjectInterfaces(context, type);\n    } else if (isInterfaceType(type)) {\n      // Ensure fields are valid.\n      validateFields(context, type);\n    } else if (isUnionType(type)) {\n      // Ensure Unions include valid member types.\n      validateUnionMembers(context, type);\n    } else if (isEnumType(type)) {\n      // Ensure Enums have valid values.\n      validateEnumValues(context, type);\n    } else if (isInputObjectType(type)) {\n      // Ensure Input Object fields are valid.\n      validateInputFields(context, type); // Ensure Input Objects do not contain non-nullable circular references\n\n      validateInputObjectCircularRefs(type);\n    }\n  }\n}\nfunction validateFields(context, type) {\n  var fields = objectValues(type.getFields()); // Objects and Interfaces both must define one or more fields.\n\n  if (fields.length === 0) {\n    context.reportError(\"Type \".concat(type.name, \" must define one or more fields.\"), getAllNodes(type));\n  }\n  for (var _i10 = 0; _i10 < fields.length; _i10++) {\n    var field = fields[_i10];\n    // Ensure they are named correctly.\n    validateName(context, field); // Ensure the type is an output type\n\n    if (!isOutputType(field.type)) {\n      context.reportError(\"The type of \".concat(type.name, \".\").concat(field.name, \" must be Output Type \") + \"but got: \".concat(inspect(field.type), \".\"), field.astNode && field.astNode.type);\n    } // Ensure the arguments are valid\n\n    var argNames = Object.create(null);\n    var _loop2 = function _loop2(_i12, _field$args2) {\n      var arg = _field$args2[_i12];\n      var argName = arg.name; // Ensure they are named correctly.\n\n      validateName(context, arg); // Ensure they are unique per field.\n\n      if (argNames[argName]) {\n        context.reportError(\"Field argument \".concat(type.name, \".\").concat(field.name, \"(\").concat(argName, \":) can only be defined once.\"), field.args.filter(function (_ref3) {\n          var name = _ref3.name;\n          return name === argName;\n        }).map(function (_ref4) {\n          var astNode = _ref4.astNode;\n          return astNode;\n        }));\n      }\n      argNames[argName] = true; // Ensure the type is an input type\n\n      if (!isInputType(arg.type)) {\n        context.reportError(\"The type of \".concat(type.name, \".\").concat(field.name, \"(\").concat(argName, \":) must be Input \") + \"Type but got: \".concat(inspect(arg.type), \".\"), arg.astNode && arg.astNode.type);\n      }\n    };\n    for (var _i12 = 0, _field$args2 = field.args; _i12 < _field$args2.length; _i12++) {\n      _loop2(_i12, _field$args2);\n    }\n  }\n}\nfunction validateObjectInterfaces(context, object) {\n  var implementedTypeNames = Object.create(null);\n  for (var _i14 = 0, _object$getInterfaces2 = object.getInterfaces(); _i14 < _object$getInterfaces2.length; _i14++) {\n    var iface = _object$getInterfaces2[_i14];\n    if (!isInterfaceType(iface)) {\n      context.reportError(\"Type \".concat(inspect(object), \" must only implement Interface types, \") + \"it cannot implement \".concat(inspect(iface), \".\"), getAllImplementsInterfaceNodes(object, iface));\n      continue;\n    }\n    if (implementedTypeNames[iface.name]) {\n      context.reportError(\"Type \".concat(object.name, \" can only implement \").concat(iface.name, \" once.\"), getAllImplementsInterfaceNodes(object, iface));\n      continue;\n    }\n    implementedTypeNames[iface.name] = true;\n    validateObjectImplementsInterface(context, object, iface);\n  }\n}\nfunction validateObjectImplementsInterface(context, object, iface) {\n  var objectFieldMap = object.getFields();\n  var ifaceFieldMap = iface.getFields(); // Assert each interface field is implemented.\n\n  for (var _i16 = 0, _objectEntries2 = objectEntries(ifaceFieldMap); _i16 < _objectEntries2.length; _i16++) {\n    var _ref6 = _objectEntries2[_i16];\n    var fieldName = _ref6[0];\n    var ifaceField = _ref6[1];\n    var objectField = objectFieldMap[fieldName]; // Assert interface field exists on object.\n\n    if (!objectField) {\n      context.reportError(\"Interface field \".concat(iface.name, \".\").concat(fieldName, \" expected but \").concat(object.name, \" does not provide it.\"), [ifaceField.astNode].concat(getAllNodes(object)));\n      continue;\n    } // Assert interface field type is satisfied by object field type, by being\n    // a valid subtype. (covariant)\n\n    if (!isTypeSubTypeOf(context.schema, objectField.type, ifaceField.type)) {\n      context.reportError(\"Interface field \".concat(iface.name, \".\").concat(fieldName, \" expects type \") + \"\".concat(inspect(ifaceField.type), \" but \").concat(object.name, \".\").concat(fieldName, \" \") + \"is type \".concat(inspect(objectField.type), \".\"), [ifaceField.astNode && ifaceField.astNode.type, objectField.astNode && objectField.astNode.type]);\n    } // Assert each interface field arg is implemented.\n\n    var _loop3 = function _loop3(_i18, _ifaceField$args2) {\n      var ifaceArg = _ifaceField$args2[_i18];\n      var argName = ifaceArg.name;\n      var objectArg = find(objectField.args, function (arg) {\n        return arg.name === argName;\n      }); // Assert interface field arg exists on object field.\n\n      if (!objectArg) {\n        context.reportError(\"Interface field argument \".concat(iface.name, \".\").concat(fieldName, \"(\").concat(argName, \":) expected but \").concat(object.name, \".\").concat(fieldName, \" does not provide it.\"), [ifaceArg.astNode, objectField.astNode]);\n        return \"continue\";\n      } // Assert interface field arg type matches object field arg type.\n      // (invariant)\n      // TODO: change to contravariant?\n\n      if (!isEqualType(ifaceArg.type, objectArg.type)) {\n        context.reportError(\"Interface field argument \".concat(iface.name, \".\").concat(fieldName, \"(\").concat(argName, \":) \") + \"expects type \".concat(inspect(ifaceArg.type), \" but \") + \"\".concat(object.name, \".\").concat(fieldName, \"(\").concat(argName, \":) is type \") + \"\".concat(inspect(objectArg.type), \".\"), [ifaceArg.astNode && ifaceArg.astNode.type, objectArg.astNode && objectArg.astNode.type]);\n      } // TODO: validate default values?\n    };\n\n    for (var _i18 = 0, _ifaceField$args2 = ifaceField.args; _i18 < _ifaceField$args2.length; _i18++) {\n      var _ret2 = _loop3(_i18, _ifaceField$args2);\n      if (_ret2 === \"continue\") continue;\n    } // Assert additional arguments must not be required.\n\n    var _loop4 = function _loop4(_i20, _objectField$args2) {\n      var objectArg = _objectField$args2[_i20];\n      var argName = objectArg.name;\n      var ifaceArg = find(ifaceField.args, function (arg) {\n        return arg.name === argName;\n      });\n      if (!ifaceArg && isRequiredArgument(objectArg)) {\n        context.reportError(\"Object field \".concat(object.name, \".\").concat(fieldName, \" includes required argument \").concat(argName, \" that is missing from the Interface field \").concat(iface.name, \".\").concat(fieldName, \".\"), [objectArg.astNode, ifaceField.astNode]);\n      }\n    };\n    for (var _i20 = 0, _objectField$args2 = objectField.args; _i20 < _objectField$args2.length; _i20++) {\n      _loop4(_i20, _objectField$args2);\n    }\n  }\n}\nfunction validateUnionMembers(context, union) {\n  var memberTypes = union.getTypes();\n  if (memberTypes.length === 0) {\n    context.reportError(\"Union type \".concat(union.name, \" must define one or more member types.\"), getAllNodes(union));\n  }\n  var includedTypeNames = Object.create(null);\n  for (var _i22 = 0; _i22 < memberTypes.length; _i22++) {\n    var memberType = memberTypes[_i22];\n    if (includedTypeNames[memberType.name]) {\n      context.reportError(\"Union type \".concat(union.name, \" can only include type \").concat(memberType.name, \" once.\"), getUnionMemberTypeNodes(union, memberType.name));\n      continue;\n    }\n    includedTypeNames[memberType.name] = true;\n    if (!isObjectType(memberType)) {\n      context.reportError(\"Union type \".concat(union.name, \" can only include Object types, \") + \"it cannot include \".concat(inspect(memberType), \".\"), getUnionMemberTypeNodes(union, String(memberType)));\n    }\n  }\n}\nfunction validateEnumValues(context, enumType) {\n  var enumValues = enumType.getValues();\n  if (enumValues.length === 0) {\n    context.reportError(\"Enum type \".concat(enumType.name, \" must define one or more values.\"), getAllNodes(enumType));\n  }\n  for (var _i24 = 0; _i24 < enumValues.length; _i24++) {\n    var enumValue = enumValues[_i24];\n    var valueName = enumValue.name; // Ensure valid name.\n\n    validateName(context, enumValue);\n    if (valueName === 'true' || valueName === 'false' || valueName === 'null') {\n      context.reportError(\"Enum type \".concat(enumType.name, \" cannot include value: \").concat(valueName, \".\"), enumValue.astNode);\n    }\n  }\n}\nfunction validateInputFields(context, inputObj) {\n  var fields = objectValues(inputObj.getFields());\n  if (fields.length === 0) {\n    context.reportError(\"Input Object type \".concat(inputObj.name, \" must define one or more fields.\"), getAllNodes(inputObj));\n  } // Ensure the arguments are valid\n\n  for (var _i26 = 0; _i26 < fields.length; _i26++) {\n    var field = fields[_i26];\n    // Ensure they are named correctly.\n    validateName(context, field); // Ensure the type is an input type\n\n    if (!isInputType(field.type)) {\n      context.reportError(\"The type of \".concat(inputObj.name, \".\").concat(field.name, \" must be Input Type \") + \"but got: \".concat(inspect(field.type), \".\"), field.astNode && field.astNode.type);\n    }\n  }\n}\nfunction createInputObjectCircularRefsValidator(context) {\n  // Modified copy of algorithm from 'src/validation/rules/NoFragmentCycles.js'.\n  // Tracks already visited types to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  var visitedTypes = Object.create(null); // Array of types nodes used to produce meaningful errors\n\n  var fieldPath = []; // Position in the type path\n\n  var fieldPathIndexByTypeName = Object.create(null);\n  return detectCycleRecursive; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(inputObj) {\n    if (visitedTypes[inputObj.name]) {\n      return;\n    }\n    visitedTypes[inputObj.name] = true;\n    fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;\n    var fields = objectValues(inputObj.getFields());\n    for (var _i28 = 0; _i28 < fields.length; _i28++) {\n      var field = fields[_i28];\n      if (isNonNullType(field.type) && isInputObjectType(field.type.ofType)) {\n        var fieldType = field.type.ofType;\n        var cycleIndex = fieldPathIndexByTypeName[fieldType.name];\n        fieldPath.push(field);\n        if (cycleIndex === undefined) {\n          detectCycleRecursive(fieldType);\n        } else {\n          var cyclePath = fieldPath.slice(cycleIndex);\n          var pathStr = cyclePath.map(function (fieldObj) {\n            return fieldObj.name;\n          }).join('.');\n          context.reportError(\"Cannot reference Input Object \\\"\".concat(fieldType.name, \"\\\" within itself through a series of non-null fields: \\\"\").concat(pathStr, \"\\\".\"), cyclePath.map(function (fieldObj) {\n            return fieldObj.astNode;\n          }));\n        }\n        fieldPath.pop();\n      }\n    }\n    fieldPathIndexByTypeName[inputObj.name] = undefined;\n  }\n}\nfunction getAllNodes(object) {\n  var astNode = object.astNode,\n    extensionASTNodes = object.extensionASTNodes;\n  return astNode ? extensionASTNodes ? [astNode].concat(extensionASTNodes) : [astNode] : extensionASTNodes || [];\n}\nfunction getAllSubNodes(object, getter) {\n  return flatMap(getAllNodes(object), function (item) {\n    return getter(item) || [];\n  });\n}\nfunction getAllImplementsInterfaceNodes(type, iface) {\n  return getAllSubNodes(type, function (typeNode) {\n    return typeNode.interfaces;\n  }).filter(function (ifaceNode) {\n    return ifaceNode.name.value === iface.name;\n  });\n}\nfunction getUnionMemberTypeNodes(union, typeName) {\n  return getAllSubNodes(union, function (unionNode) {\n    return unionNode.types;\n  }).filter(function (typeNode) {\n    return typeNode.name.value === typeName;\n  });\n}","map":{"version":3,"names":["find","flatMap","objectValues","objectEntries","inspect","GraphQLError","isValidNameError","isEqualType","isTypeSubTypeOf","isDirective","isIntrospectionType","assertSchema","isObjectType","isInterfaceType","isUnionType","isEnumType","isInputObjectType","isNamedType","isNonNullType","isInputType","isOutputType","isRequiredArgument","validateSchema","schema","__validationErrors","context","SchemaValidationContext","validateRootTypes","validateDirectives","validateTypes","errors","getErrors","assertValidSchema","length","Error","map","error","message","join","_errors","_proto","prototype","reportError","nodes","_nodes","Array","isArray","filter","Boolean","addError","push","queryType","getQueryType","astNode","concat","getOperationTypeNode","mutationType","getMutationType","subscriptionType","getSubscriptionType","type","operation","operationNodes","getAllSubNodes","node","operationTypes","_i2","_i4","_context$schema$getDi2","getDirectives","directive","validateName","argNames","Object","create","_loop","_i6","_directive$args2","arg","argName","name","args","_ref","_ref2","_ret","__allowedLegacyNames","indexOf","undefined","validateInputObjectCircularRefs","createInputObjectCircularRefsValidator","typeMap","getTypeMap","_i8","_objectValues2","validateFields","validateObjectInterfaces","validateUnionMembers","validateEnumValues","validateInputFields","fields","getFields","getAllNodes","_i10","field","_loop2","_i12","_field$args2","_ref3","_ref4","object","implementedTypeNames","_i14","_object$getInterfaces2","getInterfaces","iface","getAllImplementsInterfaceNodes","validateObjectImplementsInterface","objectFieldMap","ifaceFieldMap","_i16","_objectEntries2","_ref6","fieldName","ifaceField","objectField","_loop3","_i18","_ifaceField$args2","ifaceArg","objectArg","_ret2","_loop4","_i20","_objectField$args2","union","memberTypes","getTypes","includedTypeNames","_i22","memberType","getUnionMemberTypeNodes","String","enumType","enumValues","getValues","_i24","enumValue","valueName","inputObj","_i26","visitedTypes","fieldPath","fieldPathIndexByTypeName","detectCycleRecursive","_i28","ofType","fieldType","cycleIndex","cyclePath","slice","pathStr","fieldObj","pop","extensionASTNodes","getter","item","typeNode","interfaces","ifaceNode","value","typeName","unionNode","types"],"sources":["/Users/sviatoslav/Documents/Project3/Timekeeper/my-app/client/node_modules/graphql/type/validate.mjs"],"sourcesContent":["import find from '../polyfills/find';\nimport flatMap from '../polyfills/flatMap';\nimport objectValues from '../polyfills/objectValues';\nimport objectEntries from '../polyfills/objectEntries';\nimport inspect from '../jsutils/inspect';\nimport { GraphQLError } from '../error/GraphQLError';\nimport { isValidNameError } from '../utilities/assertValidName';\nimport { isEqualType, isTypeSubTypeOf } from '../utilities/typeComparators';\nimport { isDirective } from './directives';\nimport { isIntrospectionType } from './introspection';\nimport { assertSchema } from './schema';\nimport { isObjectType, isInterfaceType, isUnionType, isEnumType, isInputObjectType, isNamedType, isNonNullType, isInputType, isOutputType, isRequiredArgument } from './definition';\n/**\n * Implements the \"Type Validation\" sub-sections of the specification's\n * \"Type System\" section.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the Schema is valid.\n */\n\nexport function validateSchema(schema) {\n  // First check to ensure the provided value is in fact a GraphQLSchema.\n  assertSchema(schema); // If this Schema has already been validated, return the previous results.\n\n  if (schema.__validationErrors) {\n    return schema.__validationErrors;\n  } // Validate the schema, producing a list of errors.\n\n\n  var context = new SchemaValidationContext(schema);\n  validateRootTypes(context);\n  validateDirectives(context);\n  validateTypes(context); // Persist the results of validation before returning to ensure validation\n  // does not run multiple times for this schema.\n\n  var errors = context.getErrors();\n  schema.__validationErrors = errors;\n  return errors;\n}\n/**\n * Utility function which asserts a schema is valid by throwing an error if\n * it is invalid.\n */\n\nexport function assertValidSchema(schema) {\n  var errors = validateSchema(schema);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map(function (error) {\n      return error.message;\n    }).join('\\n\\n'));\n  }\n}\n\nvar SchemaValidationContext =\n/*#__PURE__*/\nfunction () {\n  function SchemaValidationContext(schema) {\n    this._errors = [];\n    this.schema = schema;\n  }\n\n  var _proto = SchemaValidationContext.prototype;\n\n  _proto.reportError = function reportError(message, nodes) {\n    var _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;\n\n    this.addError(new GraphQLError(message, _nodes));\n  };\n\n  _proto.addError = function addError(error) {\n    this._errors.push(error);\n  };\n\n  _proto.getErrors = function getErrors() {\n    return this._errors;\n  };\n\n  return SchemaValidationContext;\n}();\n\nfunction validateRootTypes(context) {\n  var schema = context.schema;\n  var queryType = schema.getQueryType();\n\n  if (!queryType) {\n    context.reportError('Query root type must be provided.', schema.astNode);\n  } else if (!isObjectType(queryType)) {\n    context.reportError(\"Query root type must be Object type, it cannot be \".concat(inspect(queryType), \".\"), getOperationTypeNode(schema, queryType, 'query'));\n  }\n\n  var mutationType = schema.getMutationType();\n\n  if (mutationType && !isObjectType(mutationType)) {\n    context.reportError('Mutation root type must be Object type if provided, it cannot be ' + \"\".concat(inspect(mutationType), \".\"), getOperationTypeNode(schema, mutationType, 'mutation'));\n  }\n\n  var subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType && !isObjectType(subscriptionType)) {\n    context.reportError('Subscription root type must be Object type if provided, it cannot be ' + \"\".concat(inspect(subscriptionType), \".\"), getOperationTypeNode(schema, subscriptionType, 'subscription'));\n  }\n}\n\nfunction getOperationTypeNode(schema, type, operation) {\n  var operationNodes = getAllSubNodes(schema, function (node) {\n    return node.operationTypes;\n  });\n\n  for (var _i2 = 0; _i2 < operationNodes.length; _i2++) {\n    var node = operationNodes[_i2];\n\n    if (node.operation === operation) {\n      return node.type;\n    }\n  }\n\n  return type.astNode;\n}\n\nfunction validateDirectives(context) {\n  for (var _i4 = 0, _context$schema$getDi2 = context.schema.getDirectives(); _i4 < _context$schema$getDi2.length; _i4++) {\n    var directive = _context$schema$getDi2[_i4];\n\n    // Ensure all directives are in fact GraphQL directives.\n    if (!isDirective(directive)) {\n      context.reportError(\"Expected directive but got: \".concat(inspect(directive), \".\"), directive && directive.astNode);\n      continue;\n    } // Ensure they are named correctly.\n\n\n    validateName(context, directive); // TODO: Ensure proper locations.\n    // Ensure the arguments are valid.\n\n    var argNames = Object.create(null);\n\n    var _loop = function _loop(_i6, _directive$args2) {\n      var arg = _directive$args2[_i6];\n      var argName = arg.name; // Ensure they are named correctly.\n\n      validateName(context, arg); // Ensure they are unique per directive.\n\n      if (argNames[argName]) {\n        context.reportError(\"Argument @\".concat(directive.name, \"(\").concat(argName, \":) can only be defined once.\"), directive.astNode && directive.args.filter(function (_ref) {\n          var name = _ref.name;\n          return name === argName;\n        }).map(function (_ref2) {\n          var astNode = _ref2.astNode;\n          return astNode;\n        }));\n        return \"continue\";\n      }\n\n      argNames[argName] = true; // Ensure the type is an input type.\n\n      if (!isInputType(arg.type)) {\n        context.reportError(\"The type of @\".concat(directive.name, \"(\").concat(argName, \":) must be Input Type \") + \"but got: \".concat(inspect(arg.type), \".\"), arg.astNode);\n      }\n    };\n\n    for (var _i6 = 0, _directive$args2 = directive.args; _i6 < _directive$args2.length; _i6++) {\n      var _ret = _loop(_i6, _directive$args2);\n\n      if (_ret === \"continue\") continue;\n    }\n  }\n}\n\nfunction validateName(context, node) {\n  // If a schema explicitly allows some legacy name which is no longer valid,\n  // allow it to be assumed valid.\n  if (context.schema.__allowedLegacyNames.indexOf(node.name) !== -1) {\n    return;\n  } // Ensure names are valid, however introspection types opt out.\n\n\n  var error = isValidNameError(node.name, node.astNode || undefined);\n\n  if (error) {\n    context.addError(error);\n  }\n}\n\nfunction validateTypes(context) {\n  var validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context);\n  var typeMap = context.schema.getTypeMap();\n\n  for (var _i8 = 0, _objectValues2 = objectValues(typeMap); _i8 < _objectValues2.length; _i8++) {\n    var type = _objectValues2[_i8];\n\n    // Ensure all provided types are in fact GraphQL type.\n    if (!isNamedType(type)) {\n      context.reportError(\"Expected GraphQL named type but got: \".concat(inspect(type), \".\"), type && type.astNode);\n      continue;\n    } // Ensure it is named correctly (excluding introspection types).\n\n\n    if (!isIntrospectionType(type)) {\n      validateName(context, type);\n    }\n\n    if (isObjectType(type)) {\n      // Ensure fields are valid\n      validateFields(context, type); // Ensure objects implement the interfaces they claim to.\n\n      validateObjectInterfaces(context, type);\n    } else if (isInterfaceType(type)) {\n      // Ensure fields are valid.\n      validateFields(context, type);\n    } else if (isUnionType(type)) {\n      // Ensure Unions include valid member types.\n      validateUnionMembers(context, type);\n    } else if (isEnumType(type)) {\n      // Ensure Enums have valid values.\n      validateEnumValues(context, type);\n    } else if (isInputObjectType(type)) {\n      // Ensure Input Object fields are valid.\n      validateInputFields(context, type); // Ensure Input Objects do not contain non-nullable circular references\n\n      validateInputObjectCircularRefs(type);\n    }\n  }\n}\n\nfunction validateFields(context, type) {\n  var fields = objectValues(type.getFields()); // Objects and Interfaces both must define one or more fields.\n\n  if (fields.length === 0) {\n    context.reportError(\"Type \".concat(type.name, \" must define one or more fields.\"), getAllNodes(type));\n  }\n\n  for (var _i10 = 0; _i10 < fields.length; _i10++) {\n    var field = fields[_i10];\n    // Ensure they are named correctly.\n    validateName(context, field); // Ensure the type is an output type\n\n    if (!isOutputType(field.type)) {\n      context.reportError(\"The type of \".concat(type.name, \".\").concat(field.name, \" must be Output Type \") + \"but got: \".concat(inspect(field.type), \".\"), field.astNode && field.astNode.type);\n    } // Ensure the arguments are valid\n\n\n    var argNames = Object.create(null);\n\n    var _loop2 = function _loop2(_i12, _field$args2) {\n      var arg = _field$args2[_i12];\n      var argName = arg.name; // Ensure they are named correctly.\n\n      validateName(context, arg); // Ensure they are unique per field.\n\n      if (argNames[argName]) {\n        context.reportError(\"Field argument \".concat(type.name, \".\").concat(field.name, \"(\").concat(argName, \":) can only be defined once.\"), field.args.filter(function (_ref3) {\n          var name = _ref3.name;\n          return name === argName;\n        }).map(function (_ref4) {\n          var astNode = _ref4.astNode;\n          return astNode;\n        }));\n      }\n\n      argNames[argName] = true; // Ensure the type is an input type\n\n      if (!isInputType(arg.type)) {\n        context.reportError(\"The type of \".concat(type.name, \".\").concat(field.name, \"(\").concat(argName, \":) must be Input \") + \"Type but got: \".concat(inspect(arg.type), \".\"), arg.astNode && arg.astNode.type);\n      }\n    };\n\n    for (var _i12 = 0, _field$args2 = field.args; _i12 < _field$args2.length; _i12++) {\n      _loop2(_i12, _field$args2);\n    }\n  }\n}\n\nfunction validateObjectInterfaces(context, object) {\n  var implementedTypeNames = Object.create(null);\n\n  for (var _i14 = 0, _object$getInterfaces2 = object.getInterfaces(); _i14 < _object$getInterfaces2.length; _i14++) {\n    var iface = _object$getInterfaces2[_i14];\n\n    if (!isInterfaceType(iface)) {\n      context.reportError(\"Type \".concat(inspect(object), \" must only implement Interface types, \") + \"it cannot implement \".concat(inspect(iface), \".\"), getAllImplementsInterfaceNodes(object, iface));\n      continue;\n    }\n\n    if (implementedTypeNames[iface.name]) {\n      context.reportError(\"Type \".concat(object.name, \" can only implement \").concat(iface.name, \" once.\"), getAllImplementsInterfaceNodes(object, iface));\n      continue;\n    }\n\n    implementedTypeNames[iface.name] = true;\n    validateObjectImplementsInterface(context, object, iface);\n  }\n}\n\nfunction validateObjectImplementsInterface(context, object, iface) {\n  var objectFieldMap = object.getFields();\n  var ifaceFieldMap = iface.getFields(); // Assert each interface field is implemented.\n\n  for (var _i16 = 0, _objectEntries2 = objectEntries(ifaceFieldMap); _i16 < _objectEntries2.length; _i16++) {\n    var _ref6 = _objectEntries2[_i16];\n    var fieldName = _ref6[0];\n    var ifaceField = _ref6[1];\n    var objectField = objectFieldMap[fieldName]; // Assert interface field exists on object.\n\n    if (!objectField) {\n      context.reportError(\"Interface field \".concat(iface.name, \".\").concat(fieldName, \" expected but \").concat(object.name, \" does not provide it.\"), [ifaceField.astNode].concat(getAllNodes(object)));\n      continue;\n    } // Assert interface field type is satisfied by object field type, by being\n    // a valid subtype. (covariant)\n\n\n    if (!isTypeSubTypeOf(context.schema, objectField.type, ifaceField.type)) {\n      context.reportError(\"Interface field \".concat(iface.name, \".\").concat(fieldName, \" expects type \") + \"\".concat(inspect(ifaceField.type), \" but \").concat(object.name, \".\").concat(fieldName, \" \") + \"is type \".concat(inspect(objectField.type), \".\"), [ifaceField.astNode && ifaceField.astNode.type, objectField.astNode && objectField.astNode.type]);\n    } // Assert each interface field arg is implemented.\n\n\n    var _loop3 = function _loop3(_i18, _ifaceField$args2) {\n      var ifaceArg = _ifaceField$args2[_i18];\n      var argName = ifaceArg.name;\n      var objectArg = find(objectField.args, function (arg) {\n        return arg.name === argName;\n      }); // Assert interface field arg exists on object field.\n\n      if (!objectArg) {\n        context.reportError(\"Interface field argument \".concat(iface.name, \".\").concat(fieldName, \"(\").concat(argName, \":) expected but \").concat(object.name, \".\").concat(fieldName, \" does not provide it.\"), [ifaceArg.astNode, objectField.astNode]);\n        return \"continue\";\n      } // Assert interface field arg type matches object field arg type.\n      // (invariant)\n      // TODO: change to contravariant?\n\n\n      if (!isEqualType(ifaceArg.type, objectArg.type)) {\n        context.reportError(\"Interface field argument \".concat(iface.name, \".\").concat(fieldName, \"(\").concat(argName, \":) \") + \"expects type \".concat(inspect(ifaceArg.type), \" but \") + \"\".concat(object.name, \".\").concat(fieldName, \"(\").concat(argName, \":) is type \") + \"\".concat(inspect(objectArg.type), \".\"), [ifaceArg.astNode && ifaceArg.astNode.type, objectArg.astNode && objectArg.astNode.type]);\n      } // TODO: validate default values?\n\n    };\n\n    for (var _i18 = 0, _ifaceField$args2 = ifaceField.args; _i18 < _ifaceField$args2.length; _i18++) {\n      var _ret2 = _loop3(_i18, _ifaceField$args2);\n\n      if (_ret2 === \"continue\") continue;\n    } // Assert additional arguments must not be required.\n\n\n    var _loop4 = function _loop4(_i20, _objectField$args2) {\n      var objectArg = _objectField$args2[_i20];\n      var argName = objectArg.name;\n      var ifaceArg = find(ifaceField.args, function (arg) {\n        return arg.name === argName;\n      });\n\n      if (!ifaceArg && isRequiredArgument(objectArg)) {\n        context.reportError(\"Object field \".concat(object.name, \".\").concat(fieldName, \" includes required argument \").concat(argName, \" that is missing from the Interface field \").concat(iface.name, \".\").concat(fieldName, \".\"), [objectArg.astNode, ifaceField.astNode]);\n      }\n    };\n\n    for (var _i20 = 0, _objectField$args2 = objectField.args; _i20 < _objectField$args2.length; _i20++) {\n      _loop4(_i20, _objectField$args2);\n    }\n  }\n}\n\nfunction validateUnionMembers(context, union) {\n  var memberTypes = union.getTypes();\n\n  if (memberTypes.length === 0) {\n    context.reportError(\"Union type \".concat(union.name, \" must define one or more member types.\"), getAllNodes(union));\n  }\n\n  var includedTypeNames = Object.create(null);\n\n  for (var _i22 = 0; _i22 < memberTypes.length; _i22++) {\n    var memberType = memberTypes[_i22];\n\n    if (includedTypeNames[memberType.name]) {\n      context.reportError(\"Union type \".concat(union.name, \" can only include type \").concat(memberType.name, \" once.\"), getUnionMemberTypeNodes(union, memberType.name));\n      continue;\n    }\n\n    includedTypeNames[memberType.name] = true;\n\n    if (!isObjectType(memberType)) {\n      context.reportError(\"Union type \".concat(union.name, \" can only include Object types, \") + \"it cannot include \".concat(inspect(memberType), \".\"), getUnionMemberTypeNodes(union, String(memberType)));\n    }\n  }\n}\n\nfunction validateEnumValues(context, enumType) {\n  var enumValues = enumType.getValues();\n\n  if (enumValues.length === 0) {\n    context.reportError(\"Enum type \".concat(enumType.name, \" must define one or more values.\"), getAllNodes(enumType));\n  }\n\n  for (var _i24 = 0; _i24 < enumValues.length; _i24++) {\n    var enumValue = enumValues[_i24];\n    var valueName = enumValue.name; // Ensure valid name.\n\n    validateName(context, enumValue);\n\n    if (valueName === 'true' || valueName === 'false' || valueName === 'null') {\n      context.reportError(\"Enum type \".concat(enumType.name, \" cannot include value: \").concat(valueName, \".\"), enumValue.astNode);\n    }\n  }\n}\n\nfunction validateInputFields(context, inputObj) {\n  var fields = objectValues(inputObj.getFields());\n\n  if (fields.length === 0) {\n    context.reportError(\"Input Object type \".concat(inputObj.name, \" must define one or more fields.\"), getAllNodes(inputObj));\n  } // Ensure the arguments are valid\n\n\n  for (var _i26 = 0; _i26 < fields.length; _i26++) {\n    var field = fields[_i26];\n    // Ensure they are named correctly.\n    validateName(context, field); // Ensure the type is an input type\n\n    if (!isInputType(field.type)) {\n      context.reportError(\"The type of \".concat(inputObj.name, \".\").concat(field.name, \" must be Input Type \") + \"but got: \".concat(inspect(field.type), \".\"), field.astNode && field.astNode.type);\n    }\n  }\n}\n\nfunction createInputObjectCircularRefsValidator(context) {\n  // Modified copy of algorithm from 'src/validation/rules/NoFragmentCycles.js'.\n  // Tracks already visited types to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  var visitedTypes = Object.create(null); // Array of types nodes used to produce meaningful errors\n\n  var fieldPath = []; // Position in the type path\n\n  var fieldPathIndexByTypeName = Object.create(null);\n  return detectCycleRecursive; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(inputObj) {\n    if (visitedTypes[inputObj.name]) {\n      return;\n    }\n\n    visitedTypes[inputObj.name] = true;\n    fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;\n    var fields = objectValues(inputObj.getFields());\n\n    for (var _i28 = 0; _i28 < fields.length; _i28++) {\n      var field = fields[_i28];\n\n      if (isNonNullType(field.type) && isInputObjectType(field.type.ofType)) {\n        var fieldType = field.type.ofType;\n        var cycleIndex = fieldPathIndexByTypeName[fieldType.name];\n        fieldPath.push(field);\n\n        if (cycleIndex === undefined) {\n          detectCycleRecursive(fieldType);\n        } else {\n          var cyclePath = fieldPath.slice(cycleIndex);\n          var pathStr = cyclePath.map(function (fieldObj) {\n            return fieldObj.name;\n          }).join('.');\n          context.reportError(\"Cannot reference Input Object \\\"\".concat(fieldType.name, \"\\\" within itself through a series of non-null fields: \\\"\").concat(pathStr, \"\\\".\"), cyclePath.map(function (fieldObj) {\n            return fieldObj.astNode;\n          }));\n        }\n\n        fieldPath.pop();\n      }\n    }\n\n    fieldPathIndexByTypeName[inputObj.name] = undefined;\n  }\n}\n\nfunction getAllNodes(object) {\n  var astNode = object.astNode,\n      extensionASTNodes = object.extensionASTNodes;\n  return astNode ? extensionASTNodes ? [astNode].concat(extensionASTNodes) : [astNode] : extensionASTNodes || [];\n}\n\nfunction getAllSubNodes(object, getter) {\n  return flatMap(getAllNodes(object), function (item) {\n    return getter(item) || [];\n  });\n}\n\nfunction getAllImplementsInterfaceNodes(type, iface) {\n  return getAllSubNodes(type, function (typeNode) {\n    return typeNode.interfaces;\n  }).filter(function (ifaceNode) {\n    return ifaceNode.name.value === iface.name;\n  });\n}\n\nfunction getUnionMemberTypeNodes(union, typeName) {\n  return getAllSubNodes(union, function (unionNode) {\n    return unionNode.types;\n  }).filter(function (typeNode) {\n    return typeNode.name.value === typeName;\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}