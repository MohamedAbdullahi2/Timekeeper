{"ast":null,"code":"import inspect from '../jsutils/inspect';\nimport invariant from '../jsutils/invariant';\nimport keyValMap from '../jsutils/keyValMap';\nimport isInvalid from '../jsutils/isInvalid';\nimport { Kind } from '../language/kinds';\n\n/**\n * Produces a JavaScript value given a GraphQL Value AST.\n *\n * Unlike `valueFromAST()`, no type is provided. The resulting JavaScript value\n * will reflect the provided GraphQL value AST.\n *\n * | GraphQL Value        | JavaScript Value |\n * | -------------------- | ---------------- |\n * | Input Object         | Object           |\n * | List                 | Array            |\n * | Boolean              | Boolean          |\n * | String / Enum        | String           |\n * | Int / Float          | Number           |\n * | Null                 | null             |\n *\n */\nexport function valueFromASTUntyped(valueNode, variables) {\n  switch (valueNode.kind) {\n    case Kind.NULL:\n      return null;\n    case Kind.INT:\n      return parseInt(valueNode.value, 10);\n    case Kind.FLOAT:\n      return parseFloat(valueNode.value);\n    case Kind.STRING:\n    case Kind.ENUM:\n    case Kind.BOOLEAN:\n      return valueNode.value;\n    case Kind.LIST:\n      return valueNode.values.map(function (node) {\n        return valueFromASTUntyped(node, variables);\n      });\n    case Kind.OBJECT:\n      return keyValMap(valueNode.fields, function (field) {\n        return field.name.value;\n      }, function (field) {\n        return valueFromASTUntyped(field.value, variables);\n      });\n    case Kind.VARIABLE:\n      {\n        var variableName = valueNode.name.value;\n        return variables && !isInvalid(variables[variableName]) ? variables[variableName] : undefined;\n      }\n  } // Not reachable. All possible value nodes have been considered.\n\n  /* istanbul ignore next */\n  invariant(false, 'Unexpected value node: ' + inspect(valueNode));\n}","map":{"version":3,"names":["inspect","invariant","keyValMap","isInvalid","Kind","valueFromASTUntyped","valueNode","variables","kind","NULL","INT","parseInt","value","FLOAT","parseFloat","STRING","ENUM","BOOLEAN","LIST","values","map","node","OBJECT","fields","field","name","VARIABLE","variableName","undefined"],"sources":["/Users/sviatoslav/Documents/Project3/Timekeeper/my-app/client/node_modules/graphql/utilities/valueFromASTUntyped.mjs"],"sourcesContent":["import inspect from '../jsutils/inspect';\nimport invariant from '../jsutils/invariant';\nimport keyValMap from '../jsutils/keyValMap';\nimport isInvalid from '../jsutils/isInvalid';\nimport { Kind } from '../language/kinds';\n\n/**\n * Produces a JavaScript value given a GraphQL Value AST.\n *\n * Unlike `valueFromAST()`, no type is provided. The resulting JavaScript value\n * will reflect the provided GraphQL value AST.\n *\n * | GraphQL Value        | JavaScript Value |\n * | -------------------- | ---------------- |\n * | Input Object         | Object           |\n * | List                 | Array            |\n * | Boolean              | Boolean          |\n * | String / Enum        | String           |\n * | Int / Float          | Number           |\n * | Null                 | null             |\n *\n */\nexport function valueFromASTUntyped(valueNode, variables) {\n  switch (valueNode.kind) {\n    case Kind.NULL:\n      return null;\n\n    case Kind.INT:\n      return parseInt(valueNode.value, 10);\n\n    case Kind.FLOAT:\n      return parseFloat(valueNode.value);\n\n    case Kind.STRING:\n    case Kind.ENUM:\n    case Kind.BOOLEAN:\n      return valueNode.value;\n\n    case Kind.LIST:\n      return valueNode.values.map(function (node) {\n        return valueFromASTUntyped(node, variables);\n      });\n\n    case Kind.OBJECT:\n      return keyValMap(valueNode.fields, function (field) {\n        return field.name.value;\n      }, function (field) {\n        return valueFromASTUntyped(field.value, variables);\n      });\n\n    case Kind.VARIABLE:\n      {\n        var variableName = valueNode.name.value;\n        return variables && !isInvalid(variables[variableName]) ? variables[variableName] : undefined;\n      }\n  } // Not reachable. All possible value nodes have been considered.\n\n\n  /* istanbul ignore next */\n  invariant(false, 'Unexpected value node: ' + inspect(valueNode));\n}\n"],"mappings":"AAAA,OAAOA,OAAO,MAAM,oBAAoB;AACxC,OAAOC,SAAS,MAAM,sBAAsB;AAC5C,OAAOC,SAAS,MAAM,sBAAsB;AAC5C,OAAOC,SAAS,MAAM,sBAAsB;AAC5C,SAASC,IAAI,QAAQ,mBAAmB;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,mBAAmBA,CAACC,SAAS,EAAEC,SAAS,EAAE;EACxD,QAAQD,SAAS,CAACE,IAAI;IACpB,KAAKJ,IAAI,CAACK,IAAI;MACZ,OAAO,IAAI;IAEb,KAAKL,IAAI,CAACM,GAAG;MACX,OAAOC,QAAQ,CAACL,SAAS,CAACM,KAAK,EAAE,EAAE,CAAC;IAEtC,KAAKR,IAAI,CAACS,KAAK;MACb,OAAOC,UAAU,CAACR,SAAS,CAACM,KAAK,CAAC;IAEpC,KAAKR,IAAI,CAACW,MAAM;IAChB,KAAKX,IAAI,CAACY,IAAI;IACd,KAAKZ,IAAI,CAACa,OAAO;MACf,OAAOX,SAAS,CAACM,KAAK;IAExB,KAAKR,IAAI,CAACc,IAAI;MACZ,OAAOZ,SAAS,CAACa,MAAM,CAACC,GAAG,CAAC,UAAUC,IAAI,EAAE;QAC1C,OAAOhB,mBAAmB,CAACgB,IAAI,EAAEd,SAAS,CAAC;MAC7C,CAAC,CAAC;IAEJ,KAAKH,IAAI,CAACkB,MAAM;MACd,OAAOpB,SAAS,CAACI,SAAS,CAACiB,MAAM,EAAE,UAAUC,KAAK,EAAE;QAClD,OAAOA,KAAK,CAACC,IAAI,CAACb,KAAK;MACzB,CAAC,EAAE,UAAUY,KAAK,EAAE;QAClB,OAAOnB,mBAAmB,CAACmB,KAAK,CAACZ,KAAK,EAAEL,SAAS,CAAC;MACpD,CAAC,CAAC;IAEJ,KAAKH,IAAI,CAACsB,QAAQ;MAChB;QACE,IAAIC,YAAY,GAAGrB,SAAS,CAACmB,IAAI,CAACb,KAAK;QACvC,OAAOL,SAAS,IAAI,CAACJ,SAAS,CAACI,SAAS,CAACoB,YAAY,CAAC,CAAC,GAAGpB,SAAS,CAACoB,YAAY,CAAC,GAAGC,SAAS;MAC/F;EACJ,CAAC,CAAC;;EAGF;EACA3B,SAAS,CAAC,KAAK,EAAE,yBAAyB,GAAGD,OAAO,CAACM,SAAS,CAAC,CAAC;AAClE"},"metadata":{},"sourceType":"module"}