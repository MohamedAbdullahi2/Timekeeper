{"ast":null,"code":"import find from '../polyfills/find';\nimport objectValues from '../polyfills/objectValues';\nimport inspect from '../jsutils/inspect';\nimport toObjMap from '../jsutils/toObjMap';\nimport devAssert from '../jsutils/devAssert';\nimport instanceOf from '../jsutils/instanceOf';\nimport isObjectLike from '../jsutils/isObjectLike';\nimport defineToStringTag from '../jsutils/defineToStringTag';\nimport { __Schema } from './introspection';\nimport { GraphQLDirective, isDirective, specifiedDirectives } from './directives';\nimport { isObjectType, isInterfaceType, isUnionType, isInputObjectType, getNamedType } from './definition';\n/**\n * Test if the given value is a GraphQL schema.\n */\n\n// eslint-disable-next-line no-redeclare\nexport function isSchema(schema) {\n  return instanceOf(schema, GraphQLSchema);\n}\nexport function assertSchema(schema) {\n  if (!isSchema(schema)) {\n    throw new Error(\"Expected \".concat(inspect(schema), \" to be a GraphQL schema.\"));\n  }\n  return schema;\n}\n/**\n * Schema Definition\n *\n * A Schema is created by supplying the root types of each type of operation,\n * query and mutation (optional). A schema definition is then supplied to the\n * validator and executor.\n *\n * Example:\n *\n *     const MyAppSchema = new GraphQLSchema({\n *       query: MyAppQueryRootType,\n *       mutation: MyAppMutationRootType,\n *     })\n *\n * Note: When the schema is constructed, by default only the types that are\n * reachable by traversing the root types are included, other types must be\n * explicitly referenced.\n *\n * Example:\n *\n *     const characterInterface = new GraphQLInterfaceType({\n *       name: 'Character',\n *       ...\n *     });\n *\n *     const humanType = new GraphQLObjectType({\n *       name: 'Human',\n *       interfaces: [characterInterface],\n *       ...\n *     });\n *\n *     const droidType = new GraphQLObjectType({\n *       name: 'Droid',\n *       interfaces: [characterInterface],\n *       ...\n *     });\n *\n *     const schema = new GraphQLSchema({\n *       query: new GraphQLObjectType({\n *         name: 'Query',\n *         fields: {\n *           hero: { type: characterInterface, ... },\n *         }\n *       }),\n *       ...\n *       // Since this schema references only the `Character` interface it's\n *       // necessary to explicitly list the types that implement it if\n *       // you want them to be included in the final schema.\n *       types: [humanType, droidType],\n *     })\n *\n * Note: If an array of `directives` are provided to GraphQLSchema, that will be\n * the exact list of directives represented and allowed. If `directives` is not\n * provided then a default set of the specified directives (e.g. @include and\n * @skip) will be used. If you wish to provide *additional* directives to these\n * specified directives, you must explicitly declare them. Example:\n *\n *     const MyAppSchema = new GraphQLSchema({\n *       ...\n *       directives: specifiedDirectives.concat([ myCustomDirective ]),\n *     })\n *\n */\n\nexport var GraphQLSchema = /*#__PURE__*/\nfunction () {\n  // Used as a cache for validateSchema().\n  // Referenced by validateSchema().\n  function GraphQLSchema(config) {\n    // If this schema was built from a source known to be valid, then it may be\n    // marked with assumeValid to avoid an additional type system validation.\n    if (config && config.assumeValid) {\n      this.__validationErrors = [];\n    } else {\n      this.__validationErrors = undefined; // Otherwise check for common mistakes during construction to produce\n      // clear and early error messages.\n\n      isObjectLike(config) || devAssert(0, 'Must provide configuration object.');\n      !config.types || Array.isArray(config.types) || devAssert(0, \"\\\"types\\\" must be Array if provided but got: \".concat(inspect(config.types), \".\"));\n      !config.directives || Array.isArray(config.directives) || devAssert(0, '\"directives\" must be Array if provided but got: ' + \"\".concat(inspect(config.directives), \".\"));\n      !config.allowedLegacyNames || Array.isArray(config.allowedLegacyNames) || devAssert(0, '\"allowedLegacyNames\" must be Array if provided but got: ' + \"\".concat(inspect(config.allowedLegacyNames), \".\"));\n    }\n    this.extensions = config.extensions && toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = config.extensionASTNodes;\n    this.__allowedLegacyNames = config.allowedLegacyNames || [];\n    this._queryType = config.query;\n    this._mutationType = config.mutation;\n    this._subscriptionType = config.subscription; // Provide specified directives (e.g. @include and @skip) by default.\n\n    this._directives = config.directives || specifiedDirectives; // Build type map now to detect any errors within this schema.\n\n    var initialTypes = [this._queryType, this._mutationType, this._subscriptionType, __Schema].concat(config.types); // Keep track of all types referenced within the schema.\n\n    var typeMap = Object.create(null); // First by deeply visiting all initial types.\n\n    typeMap = initialTypes.reduce(typeMapReducer, typeMap); // Then by deeply visiting all directive types.\n\n    typeMap = this._directives.reduce(typeMapDirectiveReducer, typeMap); // Storing the resulting map for reference by the schema.\n\n    this._typeMap = typeMap;\n    this._possibleTypeMap = Object.create(null); // Keep track of all implementations by interface name.\n\n    this._implementations = Object.create(null);\n    for (var _i2 = 0, _objectValues2 = objectValues(this._typeMap); _i2 < _objectValues2.length; _i2++) {\n      var type = _objectValues2[_i2];\n      if (isObjectType(type)) {\n        for (var _i4 = 0, _type$getInterfaces2 = type.getInterfaces(); _i4 < _type$getInterfaces2.length; _i4++) {\n          var iface = _type$getInterfaces2[_i4];\n          if (isInterfaceType(iface)) {\n            var impls = this._implementations[iface.name];\n            if (impls) {\n              impls.push(type);\n            } else {\n              this._implementations[iface.name] = [type];\n            }\n          }\n        }\n      }\n    }\n  }\n  var _proto = GraphQLSchema.prototype;\n  _proto.getQueryType = function getQueryType() {\n    return this._queryType;\n  };\n  _proto.getMutationType = function getMutationType() {\n    return this._mutationType;\n  };\n  _proto.getSubscriptionType = function getSubscriptionType() {\n    return this._subscriptionType;\n  };\n  _proto.getTypeMap = function getTypeMap() {\n    return this._typeMap;\n  };\n  _proto.getType = function getType(name) {\n    return this.getTypeMap()[name];\n  };\n  _proto.getPossibleTypes = function getPossibleTypes(abstractType) {\n    if (isUnionType(abstractType)) {\n      return abstractType.getTypes();\n    }\n    return this._implementations[abstractType.name] || [];\n  };\n  _proto.isPossibleType = function isPossibleType(abstractType, possibleType) {\n    if (this._possibleTypeMap[abstractType.name] == null) {\n      var map = Object.create(null);\n      for (var _i6 = 0, _this$getPossibleType2 = this.getPossibleTypes(abstractType); _i6 < _this$getPossibleType2.length; _i6++) {\n        var type = _this$getPossibleType2[_i6];\n        map[type.name] = true;\n      }\n      this._possibleTypeMap[abstractType.name] = map;\n    }\n    return Boolean(this._possibleTypeMap[abstractType.name][possibleType.name]);\n  };\n  _proto.getDirectives = function getDirectives() {\n    return this._directives;\n  };\n  _proto.getDirective = function getDirective(name) {\n    return find(this.getDirectives(), function (directive) {\n      return directive.name === name;\n    });\n  };\n  _proto.toConfig = function toConfig() {\n    return {\n      query: this.getQueryType(),\n      mutation: this.getMutationType(),\n      subscription: this.getSubscriptionType(),\n      types: objectValues(this.getTypeMap()),\n      directives: this.getDirectives().slice(),\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes || [],\n      assumeValid: this.__validationErrors !== undefined,\n      allowedLegacyNames: this.__allowedLegacyNames\n    };\n  };\n  return GraphQLSchema;\n}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\ndefineToStringTag(GraphQLSchema);\nfunction typeMapReducer(map, type) {\n  if (!type) {\n    return map;\n  }\n  var namedType = getNamedType(type);\n  var seenType = map[namedType.name];\n  if (seenType) {\n    if (seenType !== namedType) {\n      throw new Error(\"Schema must contain uniquely named types but contains multiple types named \\\"\".concat(namedType.name, \"\\\".\"));\n    }\n    return map;\n  }\n  map[namedType.name] = namedType;\n  var reducedMap = map;\n  if (isUnionType(namedType)) {\n    reducedMap = namedType.getTypes().reduce(typeMapReducer, reducedMap);\n  }\n  if (isObjectType(namedType)) {\n    reducedMap = namedType.getInterfaces().reduce(typeMapReducer, reducedMap);\n  }\n  if (isObjectType(namedType) || isInterfaceType(namedType)) {\n    for (var _i8 = 0, _objectValues4 = objectValues(namedType.getFields()); _i8 < _objectValues4.length; _i8++) {\n      var field = _objectValues4[_i8];\n      var fieldArgTypes = field.args.map(function (arg) {\n        return arg.type;\n      });\n      reducedMap = fieldArgTypes.reduce(typeMapReducer, reducedMap);\n      reducedMap = typeMapReducer(reducedMap, field.type);\n    }\n  }\n  if (isInputObjectType(namedType)) {\n    for (var _i10 = 0, _objectValues6 = objectValues(namedType.getFields()); _i10 < _objectValues6.length; _i10++) {\n      var _field = _objectValues6[_i10];\n      reducedMap = typeMapReducer(reducedMap, _field.type);\n    }\n  }\n  return reducedMap;\n}\nfunction typeMapDirectiveReducer(map, directive) {\n  // Directives are not validated until validateSchema() is called.\n  if (!isDirective(directive)) {\n    return map;\n  }\n  return directive.args.reduce(function (_map, arg) {\n    return typeMapReducer(_map, arg.type);\n  }, map);\n}","map":{"version":3,"names":["find","objectValues","inspect","toObjMap","devAssert","instanceOf","isObjectLike","defineToStringTag","__Schema","GraphQLDirective","isDirective","specifiedDirectives","isObjectType","isInterfaceType","isUnionType","isInputObjectType","getNamedType","isSchema","schema","GraphQLSchema","assertSchema","Error","concat","config","assumeValid","__validationErrors","undefined","types","Array","isArray","directives","allowedLegacyNames","extensions","astNode","extensionASTNodes","__allowedLegacyNames","_queryType","query","_mutationType","mutation","_subscriptionType","subscription","_directives","initialTypes","typeMap","Object","create","reduce","typeMapReducer","typeMapDirectiveReducer","_typeMap","_possibleTypeMap","_implementations","_i2","_objectValues2","length","type","_i4","_type$getInterfaces2","getInterfaces","iface","impls","name","push","_proto","prototype","getQueryType","getMutationType","getSubscriptionType","getTypeMap","getType","getPossibleTypes","abstractType","getTypes","isPossibleType","possibleType","map","_i6","_this$getPossibleType2","Boolean","getDirectives","getDirective","directive","toConfig","slice","namedType","seenType","reducedMap","_i8","_objectValues4","getFields","field","fieldArgTypes","args","arg","_i10","_objectValues6","_field","_map"],"sources":["/Users/sviatoslav/Documents/Project3/Timekeeper/my-app/client/node_modules/graphql/type/schema.mjs"],"sourcesContent":["import find from '../polyfills/find';\nimport objectValues from '../polyfills/objectValues';\nimport inspect from '../jsutils/inspect';\nimport toObjMap from '../jsutils/toObjMap';\nimport devAssert from '../jsutils/devAssert';\nimport instanceOf from '../jsutils/instanceOf';\nimport isObjectLike from '../jsutils/isObjectLike';\nimport defineToStringTag from '../jsutils/defineToStringTag';\nimport { __Schema } from './introspection';\nimport { GraphQLDirective, isDirective, specifiedDirectives } from './directives';\nimport { isObjectType, isInterfaceType, isUnionType, isInputObjectType, getNamedType } from './definition';\n/**\n * Test if the given value is a GraphQL schema.\n */\n\n// eslint-disable-next-line no-redeclare\nexport function isSchema(schema) {\n  return instanceOf(schema, GraphQLSchema);\n}\nexport function assertSchema(schema) {\n  if (!isSchema(schema)) {\n    throw new Error(\"Expected \".concat(inspect(schema), \" to be a GraphQL schema.\"));\n  }\n\n  return schema;\n}\n/**\n * Schema Definition\n *\n * A Schema is created by supplying the root types of each type of operation,\n * query and mutation (optional). A schema definition is then supplied to the\n * validator and executor.\n *\n * Example:\n *\n *     const MyAppSchema = new GraphQLSchema({\n *       query: MyAppQueryRootType,\n *       mutation: MyAppMutationRootType,\n *     })\n *\n * Note: When the schema is constructed, by default only the types that are\n * reachable by traversing the root types are included, other types must be\n * explicitly referenced.\n *\n * Example:\n *\n *     const characterInterface = new GraphQLInterfaceType({\n *       name: 'Character',\n *       ...\n *     });\n *\n *     const humanType = new GraphQLObjectType({\n *       name: 'Human',\n *       interfaces: [characterInterface],\n *       ...\n *     });\n *\n *     const droidType = new GraphQLObjectType({\n *       name: 'Droid',\n *       interfaces: [characterInterface],\n *       ...\n *     });\n *\n *     const schema = new GraphQLSchema({\n *       query: new GraphQLObjectType({\n *         name: 'Query',\n *         fields: {\n *           hero: { type: characterInterface, ... },\n *         }\n *       }),\n *       ...\n *       // Since this schema references only the `Character` interface it's\n *       // necessary to explicitly list the types that implement it if\n *       // you want them to be included in the final schema.\n *       types: [humanType, droidType],\n *     })\n *\n * Note: If an array of `directives` are provided to GraphQLSchema, that will be\n * the exact list of directives represented and allowed. If `directives` is not\n * provided then a default set of the specified directives (e.g. @include and\n * @skip) will be used. If you wish to provide *additional* directives to these\n * specified directives, you must explicitly declare them. Example:\n *\n *     const MyAppSchema = new GraphQLSchema({\n *       ...\n *       directives: specifiedDirectives.concat([ myCustomDirective ]),\n *     })\n *\n */\n\nexport var GraphQLSchema =\n/*#__PURE__*/\nfunction () {\n  // Used as a cache for validateSchema().\n  // Referenced by validateSchema().\n  function GraphQLSchema(config) {\n    // If this schema was built from a source known to be valid, then it may be\n    // marked with assumeValid to avoid an additional type system validation.\n    if (config && config.assumeValid) {\n      this.__validationErrors = [];\n    } else {\n      this.__validationErrors = undefined; // Otherwise check for common mistakes during construction to produce\n      // clear and early error messages.\n\n      isObjectLike(config) || devAssert(0, 'Must provide configuration object.');\n      !config.types || Array.isArray(config.types) || devAssert(0, \"\\\"types\\\" must be Array if provided but got: \".concat(inspect(config.types), \".\"));\n      !config.directives || Array.isArray(config.directives) || devAssert(0, '\"directives\" must be Array if provided but got: ' + \"\".concat(inspect(config.directives), \".\"));\n      !config.allowedLegacyNames || Array.isArray(config.allowedLegacyNames) || devAssert(0, '\"allowedLegacyNames\" must be Array if provided but got: ' + \"\".concat(inspect(config.allowedLegacyNames), \".\"));\n    }\n\n    this.extensions = config.extensions && toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = config.extensionASTNodes;\n    this.__allowedLegacyNames = config.allowedLegacyNames || [];\n    this._queryType = config.query;\n    this._mutationType = config.mutation;\n    this._subscriptionType = config.subscription; // Provide specified directives (e.g. @include and @skip) by default.\n\n    this._directives = config.directives || specifiedDirectives; // Build type map now to detect any errors within this schema.\n\n    var initialTypes = [this._queryType, this._mutationType, this._subscriptionType, __Schema].concat(config.types); // Keep track of all types referenced within the schema.\n\n    var typeMap = Object.create(null); // First by deeply visiting all initial types.\n\n    typeMap = initialTypes.reduce(typeMapReducer, typeMap); // Then by deeply visiting all directive types.\n\n    typeMap = this._directives.reduce(typeMapDirectiveReducer, typeMap); // Storing the resulting map for reference by the schema.\n\n    this._typeMap = typeMap;\n    this._possibleTypeMap = Object.create(null); // Keep track of all implementations by interface name.\n\n    this._implementations = Object.create(null);\n\n    for (var _i2 = 0, _objectValues2 = objectValues(this._typeMap); _i2 < _objectValues2.length; _i2++) {\n      var type = _objectValues2[_i2];\n\n      if (isObjectType(type)) {\n        for (var _i4 = 0, _type$getInterfaces2 = type.getInterfaces(); _i4 < _type$getInterfaces2.length; _i4++) {\n          var iface = _type$getInterfaces2[_i4];\n\n          if (isInterfaceType(iface)) {\n            var impls = this._implementations[iface.name];\n\n            if (impls) {\n              impls.push(type);\n            } else {\n              this._implementations[iface.name] = [type];\n            }\n          }\n        }\n      }\n    }\n  }\n\n  var _proto = GraphQLSchema.prototype;\n\n  _proto.getQueryType = function getQueryType() {\n    return this._queryType;\n  };\n\n  _proto.getMutationType = function getMutationType() {\n    return this._mutationType;\n  };\n\n  _proto.getSubscriptionType = function getSubscriptionType() {\n    return this._subscriptionType;\n  };\n\n  _proto.getTypeMap = function getTypeMap() {\n    return this._typeMap;\n  };\n\n  _proto.getType = function getType(name) {\n    return this.getTypeMap()[name];\n  };\n\n  _proto.getPossibleTypes = function getPossibleTypes(abstractType) {\n    if (isUnionType(abstractType)) {\n      return abstractType.getTypes();\n    }\n\n    return this._implementations[abstractType.name] || [];\n  };\n\n  _proto.isPossibleType = function isPossibleType(abstractType, possibleType) {\n    if (this._possibleTypeMap[abstractType.name] == null) {\n      var map = Object.create(null);\n\n      for (var _i6 = 0, _this$getPossibleType2 = this.getPossibleTypes(abstractType); _i6 < _this$getPossibleType2.length; _i6++) {\n        var type = _this$getPossibleType2[_i6];\n        map[type.name] = true;\n      }\n\n      this._possibleTypeMap[abstractType.name] = map;\n    }\n\n    return Boolean(this._possibleTypeMap[abstractType.name][possibleType.name]);\n  };\n\n  _proto.getDirectives = function getDirectives() {\n    return this._directives;\n  };\n\n  _proto.getDirective = function getDirective(name) {\n    return find(this.getDirectives(), function (directive) {\n      return directive.name === name;\n    });\n  };\n\n  _proto.toConfig = function toConfig() {\n    return {\n      query: this.getQueryType(),\n      mutation: this.getMutationType(),\n      subscription: this.getSubscriptionType(),\n      types: objectValues(this.getTypeMap()),\n      directives: this.getDirectives().slice(),\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes || [],\n      assumeValid: this.__validationErrors !== undefined,\n      allowedLegacyNames: this.__allowedLegacyNames\n    };\n  };\n\n  return GraphQLSchema;\n}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\ndefineToStringTag(GraphQLSchema);\n\nfunction typeMapReducer(map, type) {\n  if (!type) {\n    return map;\n  }\n\n  var namedType = getNamedType(type);\n  var seenType = map[namedType.name];\n\n  if (seenType) {\n    if (seenType !== namedType) {\n      throw new Error(\"Schema must contain uniquely named types but contains multiple types named \\\"\".concat(namedType.name, \"\\\".\"));\n    }\n\n    return map;\n  }\n\n  map[namedType.name] = namedType;\n  var reducedMap = map;\n\n  if (isUnionType(namedType)) {\n    reducedMap = namedType.getTypes().reduce(typeMapReducer, reducedMap);\n  }\n\n  if (isObjectType(namedType)) {\n    reducedMap = namedType.getInterfaces().reduce(typeMapReducer, reducedMap);\n  }\n\n  if (isObjectType(namedType) || isInterfaceType(namedType)) {\n    for (var _i8 = 0, _objectValues4 = objectValues(namedType.getFields()); _i8 < _objectValues4.length; _i8++) {\n      var field = _objectValues4[_i8];\n      var fieldArgTypes = field.args.map(function (arg) {\n        return arg.type;\n      });\n      reducedMap = fieldArgTypes.reduce(typeMapReducer, reducedMap);\n      reducedMap = typeMapReducer(reducedMap, field.type);\n    }\n  }\n\n  if (isInputObjectType(namedType)) {\n    for (var _i10 = 0, _objectValues6 = objectValues(namedType.getFields()); _i10 < _objectValues6.length; _i10++) {\n      var _field = _objectValues6[_i10];\n      reducedMap = typeMapReducer(reducedMap, _field.type);\n    }\n  }\n\n  return reducedMap;\n}\n\nfunction typeMapDirectiveReducer(map, directive) {\n  // Directives are not validated until validateSchema() is called.\n  if (!isDirective(directive)) {\n    return map;\n  }\n\n  return directive.args.reduce(function (_map, arg) {\n    return typeMapReducer(_map, arg.type);\n  }, map);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}