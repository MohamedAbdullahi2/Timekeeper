{"ast":null,"code":"import didYouMean from '../../jsutils/didYouMean';\nimport suggestionList from '../../jsutils/suggestionList';\nimport { GraphQLError } from '../../error/GraphQLError';\nimport { isObjectType, isInterfaceType, isAbstractType } from '../../type/definition';\nexport function undefinedFieldMessage(fieldName, type, suggestedTypeNames, suggestedFieldNames) {\n  var quotedTypeNames = suggestedTypeNames.map(function (x) {\n    return \"\\\"\".concat(x, \"\\\"\");\n  });\n  var quotedFieldNames = suggestedFieldNames.map(function (x) {\n    return \"\\\"\".concat(x, \"\\\"\");\n  });\n  return \"Cannot query field \\\"\".concat(fieldName, \"\\\" on type \\\"\").concat(type, \"\\\".\") + (didYouMean('to use an inline fragment on', quotedTypeNames) || didYouMean(quotedFieldNames));\n}\n/**\n * Fields on correct type\n *\n * A GraphQL document is only valid if all fields selected are defined by the\n * parent type, or are an allowed meta field such as __typename.\n */\n\nexport function FieldsOnCorrectType(context) {\n  return {\n    Field: function Field(node) {\n      var type = context.getParentType();\n      if (type) {\n        var fieldDef = context.getFieldDef();\n        if (!fieldDef) {\n          // This field doesn't exist, lets look for suggestions.\n          var schema = context.getSchema();\n          var fieldName = node.name.value; // First determine if there are any suggested types to condition on.\n\n          var suggestedTypeNames = getSuggestedTypeNames(schema, type, fieldName); // If there are no suggested types, then perhaps this was a typo?\n\n          var suggestedFieldNames = suggestedTypeNames.length !== 0 ? [] : getSuggestedFieldNames(schema, type, fieldName); // Report an error, including helpful suggestions.\n\n          context.reportError(new GraphQLError(undefinedFieldMessage(fieldName, type.name, suggestedTypeNames, suggestedFieldNames), node));\n        }\n      }\n    }\n  };\n}\n/**\n * Go through all of the implementations of type, as well as the interfaces that\n * they implement. If any of those types include the provided field, suggest\n * them, sorted by how often the type is referenced, starting with Interfaces.\n */\n\nfunction getSuggestedTypeNames(schema, type, fieldName) {\n  if (isAbstractType(type)) {\n    var suggestedObjectTypes = [];\n    var interfaceUsageCount = Object.create(null);\n    for (var _i2 = 0, _schema$getPossibleTy2 = schema.getPossibleTypes(type); _i2 < _schema$getPossibleTy2.length; _i2++) {\n      var possibleType = _schema$getPossibleTy2[_i2];\n      if (!possibleType.getFields()[fieldName]) {\n        continue;\n      } // This object type defines this field.\n\n      suggestedObjectTypes.push(possibleType.name);\n      for (var _i4 = 0, _possibleType$getInte2 = possibleType.getInterfaces(); _i4 < _possibleType$getInte2.length; _i4++) {\n        var possibleInterface = _possibleType$getInte2[_i4];\n        if (!possibleInterface.getFields()[fieldName]) {\n          continue;\n        } // This interface type defines this field.\n\n        interfaceUsageCount[possibleInterface.name] = (interfaceUsageCount[possibleInterface.name] || 0) + 1;\n      }\n    } // Suggest interface types based on how common they are.\n\n    var suggestedInterfaceTypes = Object.keys(interfaceUsageCount).sort(function (a, b) {\n      return interfaceUsageCount[b] - interfaceUsageCount[a];\n    }); // Suggest both interface and object types.\n\n    return suggestedInterfaceTypes.concat(suggestedObjectTypes);\n  } // Otherwise, must be an Object type, which does not have possible fields.\n\n  return [];\n}\n/**\n * For the field name provided, determine if there are any similar field names\n * that may be the result of a typo.\n */\n\nfunction getSuggestedFieldNames(schema, type, fieldName) {\n  if (isObjectType(type) || isInterfaceType(type)) {\n    var possibleFieldNames = Object.keys(type.getFields());\n    return suggestionList(fieldName, possibleFieldNames);\n  } // Otherwise, must be a Union type, which does not define fields.\n\n  return [];\n}","map":{"version":3,"names":["didYouMean","suggestionList","GraphQLError","isObjectType","isInterfaceType","isAbstractType","undefinedFieldMessage","fieldName","type","suggestedTypeNames","suggestedFieldNames","quotedTypeNames","map","x","concat","quotedFieldNames","FieldsOnCorrectType","context","Field","node","getParentType","fieldDef","getFieldDef","schema","getSchema","name","value","getSuggestedTypeNames","length","getSuggestedFieldNames","reportError","suggestedObjectTypes","interfaceUsageCount","Object","create","_i2","_schema$getPossibleTy2","getPossibleTypes","possibleType","getFields","push","_i4","_possibleType$getInte2","getInterfaces","possibleInterface","suggestedInterfaceTypes","keys","sort","a","b","possibleFieldNames"],"sources":["/Users/sviatoslav/Documents/Project3/Timekeeper/my-app/client/node_modules/graphql/validation/rules/FieldsOnCorrectType.mjs"],"sourcesContent":["import didYouMean from '../../jsutils/didYouMean';\nimport suggestionList from '../../jsutils/suggestionList';\nimport { GraphQLError } from '../../error/GraphQLError';\nimport { isObjectType, isInterfaceType, isAbstractType } from '../../type/definition';\nexport function undefinedFieldMessage(fieldName, type, suggestedTypeNames, suggestedFieldNames) {\n  var quotedTypeNames = suggestedTypeNames.map(function (x) {\n    return \"\\\"\".concat(x, \"\\\"\");\n  });\n  var quotedFieldNames = suggestedFieldNames.map(function (x) {\n    return \"\\\"\".concat(x, \"\\\"\");\n  });\n  return \"Cannot query field \\\"\".concat(fieldName, \"\\\" on type \\\"\").concat(type, \"\\\".\") + (didYouMean('to use an inline fragment on', quotedTypeNames) || didYouMean(quotedFieldNames));\n}\n/**\n * Fields on correct type\n *\n * A GraphQL document is only valid if all fields selected are defined by the\n * parent type, or are an allowed meta field such as __typename.\n */\n\nexport function FieldsOnCorrectType(context) {\n  return {\n    Field: function Field(node) {\n      var type = context.getParentType();\n\n      if (type) {\n        var fieldDef = context.getFieldDef();\n\n        if (!fieldDef) {\n          // This field doesn't exist, lets look for suggestions.\n          var schema = context.getSchema();\n          var fieldName = node.name.value; // First determine if there are any suggested types to condition on.\n\n          var suggestedTypeNames = getSuggestedTypeNames(schema, type, fieldName); // If there are no suggested types, then perhaps this was a typo?\n\n          var suggestedFieldNames = suggestedTypeNames.length !== 0 ? [] : getSuggestedFieldNames(schema, type, fieldName); // Report an error, including helpful suggestions.\n\n          context.reportError(new GraphQLError(undefinedFieldMessage(fieldName, type.name, suggestedTypeNames, suggestedFieldNames), node));\n        }\n      }\n    }\n  };\n}\n/**\n * Go through all of the implementations of type, as well as the interfaces that\n * they implement. If any of those types include the provided field, suggest\n * them, sorted by how often the type is referenced, starting with Interfaces.\n */\n\nfunction getSuggestedTypeNames(schema, type, fieldName) {\n  if (isAbstractType(type)) {\n    var suggestedObjectTypes = [];\n    var interfaceUsageCount = Object.create(null);\n\n    for (var _i2 = 0, _schema$getPossibleTy2 = schema.getPossibleTypes(type); _i2 < _schema$getPossibleTy2.length; _i2++) {\n      var possibleType = _schema$getPossibleTy2[_i2];\n\n      if (!possibleType.getFields()[fieldName]) {\n        continue;\n      } // This object type defines this field.\n\n\n      suggestedObjectTypes.push(possibleType.name);\n\n      for (var _i4 = 0, _possibleType$getInte2 = possibleType.getInterfaces(); _i4 < _possibleType$getInte2.length; _i4++) {\n        var possibleInterface = _possibleType$getInte2[_i4];\n\n        if (!possibleInterface.getFields()[fieldName]) {\n          continue;\n        } // This interface type defines this field.\n\n\n        interfaceUsageCount[possibleInterface.name] = (interfaceUsageCount[possibleInterface.name] || 0) + 1;\n      }\n    } // Suggest interface types based on how common they are.\n\n\n    var suggestedInterfaceTypes = Object.keys(interfaceUsageCount).sort(function (a, b) {\n      return interfaceUsageCount[b] - interfaceUsageCount[a];\n    }); // Suggest both interface and object types.\n\n    return suggestedInterfaceTypes.concat(suggestedObjectTypes);\n  } // Otherwise, must be an Object type, which does not have possible fields.\n\n\n  return [];\n}\n/**\n * For the field name provided, determine if there are any similar field names\n * that may be the result of a typo.\n */\n\n\nfunction getSuggestedFieldNames(schema, type, fieldName) {\n  if (isObjectType(type) || isInterfaceType(type)) {\n    var possibleFieldNames = Object.keys(type.getFields());\n    return suggestionList(fieldName, possibleFieldNames);\n  } // Otherwise, must be a Union type, which does not define fields.\n\n\n  return [];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}