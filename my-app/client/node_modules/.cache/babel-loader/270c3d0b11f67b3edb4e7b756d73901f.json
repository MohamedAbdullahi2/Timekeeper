{"ast":null,"code":"import { __assign, __extends } from 'tslib';\nimport { ApolloCache } from 'apollo-cache';\nimport { isTest, getQueryDefinition, assign, getDefaultValues, isEqual, getMainDefinition, getFragmentDefinitions, createFragmentMap, shouldInclude, isField, resultKeyNameFromField, isInlineFragment, mergeDeepArray, argumentsObjectFromField, getDirectiveInfoFromField, maybeDeepFreeze, isIdValue, getStoreKeyName, toIdValue, isJsonValue, canUseWeakMap, getOperationDefinition, isProduction, storeKeyNameFromField, addTypenameToDocument } from 'apollo-utilities';\nimport { wrap, KeyTrie } from 'optimism';\nimport { invariant, InvariantError } from 'ts-invariant';\nvar haveWarned = false;\nfunction shouldWarn() {\n  var answer = !haveWarned;\n  if (!isTest()) {\n    haveWarned = true;\n  }\n  return answer;\n}\nvar HeuristicFragmentMatcher = function () {\n  function HeuristicFragmentMatcher() {}\n  HeuristicFragmentMatcher.prototype.ensureReady = function () {\n    return Promise.resolve();\n  };\n  HeuristicFragmentMatcher.prototype.canBypassInit = function () {\n    return true;\n  };\n  HeuristicFragmentMatcher.prototype.match = function (idValue, typeCondition, context) {\n    var obj = context.store.get(idValue.id);\n    var isRootQuery = idValue.id === 'ROOT_QUERY';\n    if (!obj) {\n      return isRootQuery;\n    }\n    var _a = obj.__typename,\n      __typename = _a === void 0 ? isRootQuery && 'Query' : _a;\n    if (!__typename) {\n      if (shouldWarn()) {\n        process.env.NODE_ENV === \"production\" || invariant.warn(\"You're using fragments in your queries, but either don't have the addTypename:\\n  true option set in Apollo Client, or you are trying to write a fragment to the store without the __typename.\\n   Please turn on the addTypename option and include __typename when writing fragments so that Apollo Client\\n   can accurately match fragments.\");\n        process.env.NODE_ENV === \"production\" || invariant.warn('Could not find __typename on Fragment ', typeCondition, obj);\n        process.env.NODE_ENV === \"production\" || invariant.warn(\"DEPRECATION WARNING: using fragments without __typename is unsupported behavior \" + \"and will be removed in future versions of Apollo client. You should fix this and set addTypename to true now.\");\n      }\n      return 'heuristic';\n    }\n    if (__typename === typeCondition) {\n      return true;\n    }\n    if (shouldWarn()) {\n      process.env.NODE_ENV === \"production\" || invariant.error('You are using the simple (heuristic) fragment matcher, but your ' + 'queries contain union or interface types. Apollo Client will not be ' + 'able to accurately map fragments. To make this error go away, use ' + 'the `IntrospectionFragmentMatcher` as described in the docs: ' + 'https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher');\n    }\n    return 'heuristic';\n  };\n  return HeuristicFragmentMatcher;\n}();\nvar IntrospectionFragmentMatcher = function () {\n  function IntrospectionFragmentMatcher(options) {\n    if (options && options.introspectionQueryResultData) {\n      this.possibleTypesMap = this.parseIntrospectionResult(options.introspectionQueryResultData);\n      this.isReady = true;\n    } else {\n      this.isReady = false;\n    }\n    this.match = this.match.bind(this);\n  }\n  IntrospectionFragmentMatcher.prototype.match = function (idValue, typeCondition, context) {\n    process.env.NODE_ENV === \"production\" ? invariant(this.isReady, 1) : invariant(this.isReady, 'FragmentMatcher.match() was called before FragmentMatcher.init()');\n    var obj = context.store.get(idValue.id);\n    var isRootQuery = idValue.id === 'ROOT_QUERY';\n    if (!obj) {\n      return isRootQuery;\n    }\n    var _a = obj.__typename,\n      __typename = _a === void 0 ? isRootQuery && 'Query' : _a;\n    process.env.NODE_ENV === \"production\" ? invariant(__typename, 2) : invariant(__typename, \"Cannot match fragment because __typename property is missing: \" + JSON.stringify(obj));\n    if (__typename === typeCondition) {\n      return true;\n    }\n    var implementingTypes = this.possibleTypesMap[typeCondition];\n    if (__typename && implementingTypes && implementingTypes.indexOf(__typename) > -1) {\n      return true;\n    }\n    return false;\n  };\n  IntrospectionFragmentMatcher.prototype.parseIntrospectionResult = function (introspectionResultData) {\n    var typeMap = {};\n    introspectionResultData.__schema.types.forEach(function (type) {\n      if (type.kind === 'UNION' || type.kind === 'INTERFACE') {\n        typeMap[type.name] = type.possibleTypes.map(function (implementingType) {\n          return implementingType.name;\n        });\n      }\n    });\n    return typeMap;\n  };\n  return IntrospectionFragmentMatcher;\n}();\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar DepTrackingCache = function () {\n  function DepTrackingCache(data) {\n    var _this = this;\n    if (data === void 0) {\n      data = Object.create(null);\n    }\n    this.data = data;\n    this.depend = wrap(function (dataId) {\n      return _this.data[dataId];\n    }, {\n      disposable: true,\n      makeCacheKey: function (dataId) {\n        return dataId;\n      }\n    });\n  }\n  DepTrackingCache.prototype.toObject = function () {\n    return this.data;\n  };\n  DepTrackingCache.prototype.get = function (dataId) {\n    this.depend(dataId);\n    return this.data[dataId];\n  };\n  DepTrackingCache.prototype.set = function (dataId, value) {\n    var oldValue = this.data[dataId];\n    if (value !== oldValue) {\n      this.data[dataId] = value;\n      this.depend.dirty(dataId);\n    }\n  };\n  DepTrackingCache.prototype.delete = function (dataId) {\n    if (hasOwn.call(this.data, dataId)) {\n      delete this.data[dataId];\n      this.depend.dirty(dataId);\n    }\n  };\n  DepTrackingCache.prototype.clear = function () {\n    this.replace(null);\n  };\n  DepTrackingCache.prototype.replace = function (newData) {\n    var _this = this;\n    if (newData) {\n      Object.keys(newData).forEach(function (dataId) {\n        _this.set(dataId, newData[dataId]);\n      });\n      Object.keys(this.data).forEach(function (dataId) {\n        if (!hasOwn.call(newData, dataId)) {\n          _this.delete(dataId);\n        }\n      });\n    } else {\n      Object.keys(this.data).forEach(function (dataId) {\n        _this.delete(dataId);\n      });\n    }\n  };\n  return DepTrackingCache;\n}();\nfunction defaultNormalizedCacheFactory(seed) {\n  return new DepTrackingCache(seed);\n}\nvar StoreReader = function () {\n  function StoreReader(_a) {\n    var _this = this;\n    var _b = _a === void 0 ? {} : _a,\n      _c = _b.cacheKeyRoot,\n      cacheKeyRoot = _c === void 0 ? new KeyTrie(canUseWeakMap) : _c,\n      _d = _b.freezeResults,\n      freezeResults = _d === void 0 ? false : _d;\n    var _e = this,\n      executeStoreQuery = _e.executeStoreQuery,\n      executeSelectionSet = _e.executeSelectionSet,\n      executeSubSelectedArray = _e.executeSubSelectedArray;\n    this.freezeResults = freezeResults;\n    this.executeStoreQuery = wrap(function (options) {\n      return executeStoreQuery.call(_this, options);\n    }, {\n      makeCacheKey: function (_a) {\n        var query = _a.query,\n          rootValue = _a.rootValue,\n          contextValue = _a.contextValue,\n          variableValues = _a.variableValues,\n          fragmentMatcher = _a.fragmentMatcher;\n        if (contextValue.store instanceof DepTrackingCache) {\n          return cacheKeyRoot.lookup(contextValue.store, query, fragmentMatcher, JSON.stringify(variableValues), rootValue.id);\n        }\n      }\n    });\n    this.executeSelectionSet = wrap(function (options) {\n      return executeSelectionSet.call(_this, options);\n    }, {\n      makeCacheKey: function (_a) {\n        var selectionSet = _a.selectionSet,\n          rootValue = _a.rootValue,\n          execContext = _a.execContext;\n        if (execContext.contextValue.store instanceof DepTrackingCache) {\n          return cacheKeyRoot.lookup(execContext.contextValue.store, selectionSet, execContext.fragmentMatcher, JSON.stringify(execContext.variableValues), rootValue.id);\n        }\n      }\n    });\n    this.executeSubSelectedArray = wrap(function (options) {\n      return executeSubSelectedArray.call(_this, options);\n    }, {\n      makeCacheKey: function (_a) {\n        var field = _a.field,\n          array = _a.array,\n          execContext = _a.execContext;\n        if (execContext.contextValue.store instanceof DepTrackingCache) {\n          return cacheKeyRoot.lookup(execContext.contextValue.store, field, array, JSON.stringify(execContext.variableValues));\n        }\n      }\n    });\n  }\n  StoreReader.prototype.readQueryFromStore = function (options) {\n    return this.diffQueryAgainstStore(__assign(__assign({}, options), {\n      returnPartialData: false\n    })).result;\n  };\n  StoreReader.prototype.diffQueryAgainstStore = function (_a) {\n    var store = _a.store,\n      query = _a.query,\n      variables = _a.variables,\n      previousResult = _a.previousResult,\n      _b = _a.returnPartialData,\n      returnPartialData = _b === void 0 ? true : _b,\n      _c = _a.rootId,\n      rootId = _c === void 0 ? 'ROOT_QUERY' : _c,\n      fragmentMatcherFunction = _a.fragmentMatcherFunction,\n      config = _a.config;\n    var queryDefinition = getQueryDefinition(query);\n    variables = assign({}, getDefaultValues(queryDefinition), variables);\n    var context = {\n      store: store,\n      dataIdFromObject: config && config.dataIdFromObject,\n      cacheRedirects: config && config.cacheRedirects || {}\n    };\n    var execResult = this.executeStoreQuery({\n      query: query,\n      rootValue: {\n        type: 'id',\n        id: rootId,\n        generated: true,\n        typename: 'Query'\n      },\n      contextValue: context,\n      variableValues: variables,\n      fragmentMatcher: fragmentMatcherFunction\n    });\n    var hasMissingFields = execResult.missing && execResult.missing.length > 0;\n    if (hasMissingFields && !returnPartialData) {\n      execResult.missing.forEach(function (info) {\n        if (info.tolerable) return;\n        throw process.env.NODE_ENV === \"production\" ? new InvariantError(8) : new InvariantError(\"Can't find field \" + info.fieldName + \" on object \" + JSON.stringify(info.object, null, 2) + \".\");\n      });\n    }\n    if (previousResult) {\n      if (isEqual(previousResult, execResult.result)) {\n        execResult.result = previousResult;\n      }\n    }\n    return {\n      result: execResult.result,\n      complete: !hasMissingFields\n    };\n  };\n  StoreReader.prototype.executeStoreQuery = function (_a) {\n    var query = _a.query,\n      rootValue = _a.rootValue,\n      contextValue = _a.contextValue,\n      variableValues = _a.variableValues,\n      _b = _a.fragmentMatcher,\n      fragmentMatcher = _b === void 0 ? defaultFragmentMatcher : _b;\n    var mainDefinition = getMainDefinition(query);\n    var fragments = getFragmentDefinitions(query);\n    var fragmentMap = createFragmentMap(fragments);\n    var execContext = {\n      query: query,\n      fragmentMap: fragmentMap,\n      contextValue: contextValue,\n      variableValues: variableValues,\n      fragmentMatcher: fragmentMatcher\n    };\n    return this.executeSelectionSet({\n      selectionSet: mainDefinition.selectionSet,\n      rootValue: rootValue,\n      execContext: execContext\n    });\n  };\n  StoreReader.prototype.executeSelectionSet = function (_a) {\n    var _this = this;\n    var selectionSet = _a.selectionSet,\n      rootValue = _a.rootValue,\n      execContext = _a.execContext;\n    var fragmentMap = execContext.fragmentMap,\n      contextValue = execContext.contextValue,\n      variables = execContext.variableValues;\n    var finalResult = {\n      result: null\n    };\n    var objectsToMerge = [];\n    var object = contextValue.store.get(rootValue.id);\n    var typename = object && object.__typename || rootValue.id === 'ROOT_QUERY' && 'Query' || void 0;\n    function handleMissing(result) {\n      var _a;\n      if (result.missing) {\n        finalResult.missing = finalResult.missing || [];\n        (_a = finalResult.missing).push.apply(_a, result.missing);\n      }\n      return result.result;\n    }\n    selectionSet.selections.forEach(function (selection) {\n      var _a;\n      if (!shouldInclude(selection, variables)) {\n        return;\n      }\n      if (isField(selection)) {\n        var fieldResult = handleMissing(_this.executeField(object, typename, selection, execContext));\n        if (typeof fieldResult !== 'undefined') {\n          objectsToMerge.push((_a = {}, _a[resultKeyNameFromField(selection)] = fieldResult, _a));\n        }\n      } else {\n        var fragment = void 0;\n        if (isInlineFragment(selection)) {\n          fragment = selection;\n        } else {\n          fragment = fragmentMap[selection.name.value];\n          if (!fragment) {\n            throw process.env.NODE_ENV === \"production\" ? new InvariantError(9) : new InvariantError(\"No fragment named \" + selection.name.value);\n          }\n        }\n        var typeCondition = fragment.typeCondition && fragment.typeCondition.name.value;\n        var match = !typeCondition || execContext.fragmentMatcher(rootValue, typeCondition, contextValue);\n        if (match) {\n          var fragmentExecResult = _this.executeSelectionSet({\n            selectionSet: fragment.selectionSet,\n            rootValue: rootValue,\n            execContext: execContext\n          });\n          if (match === 'heuristic' && fragmentExecResult.missing) {\n            fragmentExecResult = __assign(__assign({}, fragmentExecResult), {\n              missing: fragmentExecResult.missing.map(function (info) {\n                return __assign(__assign({}, info), {\n                  tolerable: true\n                });\n              })\n            });\n          }\n          objectsToMerge.push(handleMissing(fragmentExecResult));\n        }\n      }\n    });\n    finalResult.result = mergeDeepArray(objectsToMerge);\n    if (this.freezeResults && process.env.NODE_ENV !== 'production') {\n      Object.freeze(finalResult.result);\n    }\n    return finalResult;\n  };\n  StoreReader.prototype.executeField = function (object, typename, field, execContext) {\n    var variables = execContext.variableValues,\n      contextValue = execContext.contextValue;\n    var fieldName = field.name.value;\n    var args = argumentsObjectFromField(field, variables);\n    var info = {\n      resultKey: resultKeyNameFromField(field),\n      directives: getDirectiveInfoFromField(field, variables)\n    };\n    var readStoreResult = readStoreResolver(object, typename, fieldName, args, contextValue, info);\n    if (Array.isArray(readStoreResult.result)) {\n      return this.combineExecResults(readStoreResult, this.executeSubSelectedArray({\n        field: field,\n        array: readStoreResult.result,\n        execContext: execContext\n      }));\n    }\n    if (!field.selectionSet) {\n      assertSelectionSetForIdValue(field, readStoreResult.result);\n      if (this.freezeResults && process.env.NODE_ENV !== 'production') {\n        maybeDeepFreeze(readStoreResult);\n      }\n      return readStoreResult;\n    }\n    if (readStoreResult.result == null) {\n      return readStoreResult;\n    }\n    return this.combineExecResults(readStoreResult, this.executeSelectionSet({\n      selectionSet: field.selectionSet,\n      rootValue: readStoreResult.result,\n      execContext: execContext\n    }));\n  };\n  StoreReader.prototype.combineExecResults = function () {\n    var execResults = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      execResults[_i] = arguments[_i];\n    }\n    var missing;\n    execResults.forEach(function (execResult) {\n      if (execResult.missing) {\n        missing = missing || [];\n        missing.push.apply(missing, execResult.missing);\n      }\n    });\n    return {\n      result: execResults.pop().result,\n      missing: missing\n    };\n  };\n  StoreReader.prototype.executeSubSelectedArray = function (_a) {\n    var _this = this;\n    var field = _a.field,\n      array = _a.array,\n      execContext = _a.execContext;\n    var missing;\n    function handleMissing(childResult) {\n      if (childResult.missing) {\n        missing = missing || [];\n        missing.push.apply(missing, childResult.missing);\n      }\n      return childResult.result;\n    }\n    array = array.map(function (item) {\n      if (item === null) {\n        return null;\n      }\n      if (Array.isArray(item)) {\n        return handleMissing(_this.executeSubSelectedArray({\n          field: field,\n          array: item,\n          execContext: execContext\n        }));\n      }\n      if (field.selectionSet) {\n        return handleMissing(_this.executeSelectionSet({\n          selectionSet: field.selectionSet,\n          rootValue: item,\n          execContext: execContext\n        }));\n      }\n      assertSelectionSetForIdValue(field, item);\n      return item;\n    });\n    if (this.freezeResults && process.env.NODE_ENV !== 'production') {\n      Object.freeze(array);\n    }\n    return {\n      result: array,\n      missing: missing\n    };\n  };\n  return StoreReader;\n}();\nfunction assertSelectionSetForIdValue(field, value) {\n  if (!field.selectionSet && isIdValue(value)) {\n    throw process.env.NODE_ENV === \"production\" ? new InvariantError(10) : new InvariantError(\"Missing selection set for object of type \" + value.typename + \" returned for query field \" + field.name.value);\n  }\n}\nfunction defaultFragmentMatcher() {\n  return true;\n}\nfunction assertIdValue(idValue) {\n  process.env.NODE_ENV === \"production\" ? invariant(isIdValue(idValue), 11) : invariant(isIdValue(idValue), \"Encountered a sub-selection on the query, but the store doesn't have an object reference. This should never happen during normal use unless you have custom code that is directly manipulating the store; please file an issue.\");\n}\nfunction readStoreResolver(object, typename, fieldName, args, context, _a) {\n  var resultKey = _a.resultKey,\n    directives = _a.directives;\n  var storeKeyName = fieldName;\n  if (args || directives) {\n    storeKeyName = getStoreKeyName(storeKeyName, args, directives);\n  }\n  var fieldValue = void 0;\n  if (object) {\n    fieldValue = object[storeKeyName];\n    if (typeof fieldValue === 'undefined' && context.cacheRedirects && typeof typename === 'string') {\n      var type = context.cacheRedirects[typename];\n      if (type) {\n        var resolver = type[fieldName];\n        if (resolver) {\n          fieldValue = resolver(object, args, {\n            getCacheKey: function (storeObj) {\n              var id = context.dataIdFromObject(storeObj);\n              return id && toIdValue({\n                id: id,\n                typename: storeObj.__typename\n              });\n            }\n          });\n        }\n      }\n    }\n  }\n  if (typeof fieldValue === 'undefined') {\n    return {\n      result: fieldValue,\n      missing: [{\n        object: object,\n        fieldName: storeKeyName,\n        tolerable: false\n      }]\n    };\n  }\n  if (isJsonValue(fieldValue)) {\n    fieldValue = fieldValue.json;\n  }\n  return {\n    result: fieldValue\n  };\n}\nvar ObjectCache = function () {\n  function ObjectCache(data) {\n    if (data === void 0) {\n      data = Object.create(null);\n    }\n    this.data = data;\n  }\n  ObjectCache.prototype.toObject = function () {\n    return this.data;\n  };\n  ObjectCache.prototype.get = function (dataId) {\n    return this.data[dataId];\n  };\n  ObjectCache.prototype.set = function (dataId, value) {\n    this.data[dataId] = value;\n  };\n  ObjectCache.prototype.delete = function (dataId) {\n    this.data[dataId] = void 0;\n  };\n  ObjectCache.prototype.clear = function () {\n    this.data = Object.create(null);\n  };\n  ObjectCache.prototype.replace = function (newData) {\n    this.data = newData || Object.create(null);\n  };\n  return ObjectCache;\n}();\nfunction defaultNormalizedCacheFactory$1(seed) {\n  return new ObjectCache(seed);\n}\nvar WriteError = function (_super) {\n  __extends(WriteError, _super);\n  function WriteError() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = 'WriteError';\n    return _this;\n  }\n  return WriteError;\n}(Error);\nfunction enhanceErrorWithDocument(error, document) {\n  var enhancedError = new WriteError(\"Error writing result to store for query:\\n \" + JSON.stringify(document));\n  enhancedError.message += '\\n' + error.message;\n  enhancedError.stack = error.stack;\n  return enhancedError;\n}\nvar StoreWriter = function () {\n  function StoreWriter() {}\n  StoreWriter.prototype.writeQueryToStore = function (_a) {\n    var query = _a.query,\n      result = _a.result,\n      _b = _a.store,\n      store = _b === void 0 ? defaultNormalizedCacheFactory() : _b,\n      variables = _a.variables,\n      dataIdFromObject = _a.dataIdFromObject,\n      fragmentMatcherFunction = _a.fragmentMatcherFunction;\n    return this.writeResultToStore({\n      dataId: 'ROOT_QUERY',\n      result: result,\n      document: query,\n      store: store,\n      variables: variables,\n      dataIdFromObject: dataIdFromObject,\n      fragmentMatcherFunction: fragmentMatcherFunction\n    });\n  };\n  StoreWriter.prototype.writeResultToStore = function (_a) {\n    var dataId = _a.dataId,\n      result = _a.result,\n      document = _a.document,\n      _b = _a.store,\n      store = _b === void 0 ? defaultNormalizedCacheFactory() : _b,\n      variables = _a.variables,\n      dataIdFromObject = _a.dataIdFromObject,\n      fragmentMatcherFunction = _a.fragmentMatcherFunction;\n    var operationDefinition = getOperationDefinition(document);\n    try {\n      return this.writeSelectionSetToStore({\n        result: result,\n        dataId: dataId,\n        selectionSet: operationDefinition.selectionSet,\n        context: {\n          store: store,\n          processedData: {},\n          variables: assign({}, getDefaultValues(operationDefinition), variables),\n          dataIdFromObject: dataIdFromObject,\n          fragmentMap: createFragmentMap(getFragmentDefinitions(document)),\n          fragmentMatcherFunction: fragmentMatcherFunction\n        }\n      });\n    } catch (e) {\n      throw enhanceErrorWithDocument(e, document);\n    }\n  };\n  StoreWriter.prototype.writeSelectionSetToStore = function (_a) {\n    var _this = this;\n    var result = _a.result,\n      dataId = _a.dataId,\n      selectionSet = _a.selectionSet,\n      context = _a.context;\n    var variables = context.variables,\n      store = context.store,\n      fragmentMap = context.fragmentMap;\n    selectionSet.selections.forEach(function (selection) {\n      var _a;\n      if (!shouldInclude(selection, variables)) {\n        return;\n      }\n      if (isField(selection)) {\n        var resultFieldKey = resultKeyNameFromField(selection);\n        var value = result[resultFieldKey];\n        if (typeof value !== 'undefined') {\n          _this.writeFieldToStore({\n            dataId: dataId,\n            value: value,\n            field: selection,\n            context: context\n          });\n        } else {\n          var isDefered = false;\n          var isClient = false;\n          if (selection.directives && selection.directives.length) {\n            isDefered = selection.directives.some(function (directive) {\n              return directive.name && directive.name.value === 'defer';\n            });\n            isClient = selection.directives.some(function (directive) {\n              return directive.name && directive.name.value === 'client';\n            });\n          }\n          if (!isDefered && !isClient && context.fragmentMatcherFunction) {\n            process.env.NODE_ENV === \"production\" || invariant.warn(\"Missing field \" + resultFieldKey + \" in \" + JSON.stringify(result, null, 2).substring(0, 100));\n          }\n        }\n      } else {\n        var fragment = void 0;\n        if (isInlineFragment(selection)) {\n          fragment = selection;\n        } else {\n          fragment = (fragmentMap || {})[selection.name.value];\n          process.env.NODE_ENV === \"production\" ? invariant(fragment, 3) : invariant(fragment, \"No fragment named \" + selection.name.value + \".\");\n        }\n        var matches = true;\n        if (context.fragmentMatcherFunction && fragment.typeCondition) {\n          var id = dataId || 'self';\n          var idValue = toIdValue({\n            id: id,\n            typename: undefined\n          });\n          var fakeContext = {\n            store: new ObjectCache((_a = {}, _a[id] = result, _a)),\n            cacheRedirects: {}\n          };\n          var match = context.fragmentMatcherFunction(idValue, fragment.typeCondition.name.value, fakeContext);\n          if (!isProduction() && match === 'heuristic') {\n            process.env.NODE_ENV === \"production\" || invariant.error('WARNING: heuristic fragment matching going on!');\n          }\n          matches = !!match;\n        }\n        if (matches) {\n          _this.writeSelectionSetToStore({\n            result: result,\n            selectionSet: fragment.selectionSet,\n            dataId: dataId,\n            context: context\n          });\n        }\n      }\n    });\n    return store;\n  };\n  StoreWriter.prototype.writeFieldToStore = function (_a) {\n    var _b;\n    var field = _a.field,\n      value = _a.value,\n      dataId = _a.dataId,\n      context = _a.context;\n    var variables = context.variables,\n      dataIdFromObject = context.dataIdFromObject,\n      store = context.store;\n    var storeValue;\n    var storeObject;\n    var storeFieldName = storeKeyNameFromField(field, variables);\n    if (!field.selectionSet || value === null) {\n      storeValue = value != null && typeof value === 'object' ? {\n        type: 'json',\n        json: value\n      } : value;\n    } else if (Array.isArray(value)) {\n      var generatedId = dataId + \".\" + storeFieldName;\n      storeValue = this.processArrayValue(value, generatedId, field.selectionSet, context);\n    } else {\n      var valueDataId = dataId + \".\" + storeFieldName;\n      var generated = true;\n      if (!isGeneratedId(valueDataId)) {\n        valueDataId = '$' + valueDataId;\n      }\n      if (dataIdFromObject) {\n        var semanticId = dataIdFromObject(value);\n        process.env.NODE_ENV === \"production\" ? invariant(!semanticId || !isGeneratedId(semanticId), 4) : invariant(!semanticId || !isGeneratedId(semanticId), 'IDs returned by dataIdFromObject cannot begin with the \"$\" character.');\n        if (semanticId || typeof semanticId === 'number' && semanticId === 0) {\n          valueDataId = semanticId;\n          generated = false;\n        }\n      }\n      if (!isDataProcessed(valueDataId, field, context.processedData)) {\n        this.writeSelectionSetToStore({\n          dataId: valueDataId,\n          result: value,\n          selectionSet: field.selectionSet,\n          context: context\n        });\n      }\n      var typename = value.__typename;\n      storeValue = toIdValue({\n        id: valueDataId,\n        typename: typename\n      }, generated);\n      storeObject = store.get(dataId);\n      var escapedId = storeObject && storeObject[storeFieldName];\n      if (escapedId !== storeValue && isIdValue(escapedId)) {\n        var hadTypename = escapedId.typename !== undefined;\n        var hasTypename = typename !== undefined;\n        var typenameChanged = hadTypename && hasTypename && escapedId.typename !== typename;\n        process.env.NODE_ENV === \"production\" ? invariant(!generated || escapedId.generated || typenameChanged, 5) : invariant(!generated || escapedId.generated || typenameChanged, \"Store error: the application attempted to write an object with no provided id but the store already contains an id of \" + escapedId.id + \" for this object. The selectionSet that was trying to be written is:\\n\" + JSON.stringify(field));\n        process.env.NODE_ENV === \"production\" ? invariant(!hadTypename || hasTypename, 6) : invariant(!hadTypename || hasTypename, \"Store error: the application attempted to write an object with no provided typename but the store already contains an object with typename of \" + escapedId.typename + \" for the object of id \" + escapedId.id + \". The selectionSet that was trying to be written is:\\n\" + JSON.stringify(field));\n        if (escapedId.generated) {\n          if (typenameChanged) {\n            if (!generated) {\n              store.delete(escapedId.id);\n            }\n          } else {\n            mergeWithGenerated(escapedId.id, storeValue.id, store);\n          }\n        }\n      }\n    }\n    storeObject = store.get(dataId);\n    if (!storeObject || !isEqual(storeValue, storeObject[storeFieldName])) {\n      store.set(dataId, __assign(__assign({}, storeObject), (_b = {}, _b[storeFieldName] = storeValue, _b)));\n    }\n  };\n  StoreWriter.prototype.processArrayValue = function (value, generatedId, selectionSet, context) {\n    var _this = this;\n    return value.map(function (item, index) {\n      if (item === null) {\n        return null;\n      }\n      var itemDataId = generatedId + \".\" + index;\n      if (Array.isArray(item)) {\n        return _this.processArrayValue(item, itemDataId, selectionSet, context);\n      }\n      var generated = true;\n      if (context.dataIdFromObject) {\n        var semanticId = context.dataIdFromObject(item);\n        if (semanticId) {\n          itemDataId = semanticId;\n          generated = false;\n        }\n      }\n      if (!isDataProcessed(itemDataId, selectionSet, context.processedData)) {\n        _this.writeSelectionSetToStore({\n          dataId: itemDataId,\n          result: item,\n          selectionSet: selectionSet,\n          context: context\n        });\n      }\n      return toIdValue({\n        id: itemDataId,\n        typename: item.__typename\n      }, generated);\n    });\n  };\n  return StoreWriter;\n}();\nfunction isGeneratedId(id) {\n  return id[0] === '$';\n}\nfunction mergeWithGenerated(generatedKey, realKey, cache) {\n  if (generatedKey === realKey) {\n    return false;\n  }\n  var generated = cache.get(generatedKey);\n  var real = cache.get(realKey);\n  var madeChanges = false;\n  Object.keys(generated).forEach(function (key) {\n    var value = generated[key];\n    var realValue = real[key];\n    if (isIdValue(value) && isGeneratedId(value.id) && isIdValue(realValue) && !isEqual(value, realValue) && mergeWithGenerated(value.id, realValue.id, cache)) {\n      madeChanges = true;\n    }\n  });\n  cache.delete(generatedKey);\n  var newRealValue = __assign(__assign({}, generated), real);\n  if (isEqual(newRealValue, real)) {\n    return madeChanges;\n  }\n  cache.set(realKey, newRealValue);\n  return true;\n}\nfunction isDataProcessed(dataId, field, processedData) {\n  if (!processedData) {\n    return false;\n  }\n  if (processedData[dataId]) {\n    if (processedData[dataId].indexOf(field) >= 0) {\n      return true;\n    } else {\n      processedData[dataId].push(field);\n    }\n  } else {\n    processedData[dataId] = [field];\n  }\n  return false;\n}\nvar defaultConfig = {\n  fragmentMatcher: new HeuristicFragmentMatcher(),\n  dataIdFromObject: defaultDataIdFromObject,\n  addTypename: true,\n  resultCaching: true,\n  freezeResults: false\n};\nfunction defaultDataIdFromObject(result) {\n  if (result.__typename) {\n    if (result.id !== undefined) {\n      return result.__typename + \":\" + result.id;\n    }\n    if (result._id !== undefined) {\n      return result.__typename + \":\" + result._id;\n    }\n  }\n  return null;\n}\nvar hasOwn$1 = Object.prototype.hasOwnProperty;\nvar OptimisticCacheLayer = function (_super) {\n  __extends(OptimisticCacheLayer, _super);\n  function OptimisticCacheLayer(optimisticId, parent, transaction) {\n    var _this = _super.call(this, Object.create(null)) || this;\n    _this.optimisticId = optimisticId;\n    _this.parent = parent;\n    _this.transaction = transaction;\n    return _this;\n  }\n  OptimisticCacheLayer.prototype.toObject = function () {\n    return __assign(__assign({}, this.parent.toObject()), this.data);\n  };\n  OptimisticCacheLayer.prototype.get = function (dataId) {\n    return hasOwn$1.call(this.data, dataId) ? this.data[dataId] : this.parent.get(dataId);\n  };\n  return OptimisticCacheLayer;\n}(ObjectCache);\nvar InMemoryCache = function (_super) {\n  __extends(InMemoryCache, _super);\n  function InMemoryCache(config) {\n    if (config === void 0) {\n      config = {};\n    }\n    var _this = _super.call(this) || this;\n    _this.watches = new Set();\n    _this.typenameDocumentCache = new Map();\n    _this.cacheKeyRoot = new KeyTrie(canUseWeakMap);\n    _this.silenceBroadcast = false;\n    _this.config = __assign(__assign({}, defaultConfig), config);\n    if (_this.config.customResolvers) {\n      process.env.NODE_ENV === \"production\" || invariant.warn('customResolvers have been renamed to cacheRedirects. Please update your config as we will be deprecating customResolvers in the next major version.');\n      _this.config.cacheRedirects = _this.config.customResolvers;\n    }\n    if (_this.config.cacheResolvers) {\n      process.env.NODE_ENV === \"production\" || invariant.warn('cacheResolvers have been renamed to cacheRedirects. Please update your config as we will be deprecating cacheResolvers in the next major version.');\n      _this.config.cacheRedirects = _this.config.cacheResolvers;\n    }\n    _this.addTypename = !!_this.config.addTypename;\n    _this.data = _this.config.resultCaching ? new DepTrackingCache() : new ObjectCache();\n    _this.optimisticData = _this.data;\n    _this.storeWriter = new StoreWriter();\n    _this.storeReader = new StoreReader({\n      cacheKeyRoot: _this.cacheKeyRoot,\n      freezeResults: config.freezeResults\n    });\n    var cache = _this;\n    var maybeBroadcastWatch = cache.maybeBroadcastWatch;\n    _this.maybeBroadcastWatch = wrap(function (c) {\n      return maybeBroadcastWatch.call(_this, c);\n    }, {\n      makeCacheKey: function (c) {\n        if (c.optimistic) {\n          return;\n        }\n        if (c.previousResult) {\n          return;\n        }\n        if (cache.data instanceof DepTrackingCache) {\n          return cache.cacheKeyRoot.lookup(c.query, JSON.stringify(c.variables));\n        }\n      }\n    });\n    return _this;\n  }\n  InMemoryCache.prototype.restore = function (data) {\n    if (data) this.data.replace(data);\n    return this;\n  };\n  InMemoryCache.prototype.extract = function (optimistic) {\n    if (optimistic === void 0) {\n      optimistic = false;\n    }\n    return (optimistic ? this.optimisticData : this.data).toObject();\n  };\n  InMemoryCache.prototype.read = function (options) {\n    if (typeof options.rootId === 'string' && typeof this.data.get(options.rootId) === 'undefined') {\n      return null;\n    }\n    var fragmentMatcher = this.config.fragmentMatcher;\n    var fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;\n    return this.storeReader.readQueryFromStore({\n      store: options.optimistic ? this.optimisticData : this.data,\n      query: this.transformDocument(options.query),\n      variables: options.variables,\n      rootId: options.rootId,\n      fragmentMatcherFunction: fragmentMatcherFunction,\n      previousResult: options.previousResult,\n      config: this.config\n    }) || null;\n  };\n  InMemoryCache.prototype.write = function (write) {\n    var fragmentMatcher = this.config.fragmentMatcher;\n    var fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;\n    this.storeWriter.writeResultToStore({\n      dataId: write.dataId,\n      result: write.result,\n      variables: write.variables,\n      document: this.transformDocument(write.query),\n      store: this.data,\n      dataIdFromObject: this.config.dataIdFromObject,\n      fragmentMatcherFunction: fragmentMatcherFunction\n    });\n    this.broadcastWatches();\n  };\n  InMemoryCache.prototype.diff = function (query) {\n    var fragmentMatcher = this.config.fragmentMatcher;\n    var fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;\n    return this.storeReader.diffQueryAgainstStore({\n      store: query.optimistic ? this.optimisticData : this.data,\n      query: this.transformDocument(query.query),\n      variables: query.variables,\n      returnPartialData: query.returnPartialData,\n      previousResult: query.previousResult,\n      fragmentMatcherFunction: fragmentMatcherFunction,\n      config: this.config\n    });\n  };\n  InMemoryCache.prototype.watch = function (watch) {\n    var _this = this;\n    this.watches.add(watch);\n    return function () {\n      _this.watches.delete(watch);\n    };\n  };\n  InMemoryCache.prototype.evict = function (query) {\n    throw process.env.NODE_ENV === \"production\" ? new InvariantError(7) : new InvariantError(\"eviction is not implemented on InMemory Cache\");\n  };\n  InMemoryCache.prototype.reset = function () {\n    this.data.clear();\n    this.broadcastWatches();\n    return Promise.resolve();\n  };\n  InMemoryCache.prototype.removeOptimistic = function (idToRemove) {\n    var toReapply = [];\n    var removedCount = 0;\n    var layer = this.optimisticData;\n    while (layer instanceof OptimisticCacheLayer) {\n      if (layer.optimisticId === idToRemove) {\n        ++removedCount;\n      } else {\n        toReapply.push(layer);\n      }\n      layer = layer.parent;\n    }\n    if (removedCount > 0) {\n      this.optimisticData = layer;\n      while (toReapply.length > 0) {\n        var layer_1 = toReapply.pop();\n        this.performTransaction(layer_1.transaction, layer_1.optimisticId);\n      }\n      this.broadcastWatches();\n    }\n  };\n  InMemoryCache.prototype.performTransaction = function (transaction, optimisticId) {\n    var _a = this,\n      data = _a.data,\n      silenceBroadcast = _a.silenceBroadcast;\n    this.silenceBroadcast = true;\n    if (typeof optimisticId === 'string') {\n      this.data = this.optimisticData = new OptimisticCacheLayer(optimisticId, this.optimisticData, transaction);\n    }\n    try {\n      transaction(this);\n    } finally {\n      this.silenceBroadcast = silenceBroadcast;\n      this.data = data;\n    }\n    this.broadcastWatches();\n  };\n  InMemoryCache.prototype.recordOptimisticTransaction = function (transaction, id) {\n    return this.performTransaction(transaction, id);\n  };\n  InMemoryCache.prototype.transformDocument = function (document) {\n    if (this.addTypename) {\n      var result = this.typenameDocumentCache.get(document);\n      if (!result) {\n        result = addTypenameToDocument(document);\n        this.typenameDocumentCache.set(document, result);\n        this.typenameDocumentCache.set(result, result);\n      }\n      return result;\n    }\n    return document;\n  };\n  InMemoryCache.prototype.broadcastWatches = function () {\n    var _this = this;\n    if (!this.silenceBroadcast) {\n      this.watches.forEach(function (c) {\n        return _this.maybeBroadcastWatch(c);\n      });\n    }\n  };\n  InMemoryCache.prototype.maybeBroadcastWatch = function (c) {\n    c.callback(this.diff({\n      query: c.query,\n      variables: c.variables,\n      previousResult: c.previousResult && c.previousResult(),\n      optimistic: c.optimistic\n    }));\n  };\n  return InMemoryCache;\n}(ApolloCache);\nexport { HeuristicFragmentMatcher, InMemoryCache, IntrospectionFragmentMatcher, ObjectCache, StoreReader, StoreWriter, WriteError, assertIdValue, defaultDataIdFromObject, defaultNormalizedCacheFactory$1 as defaultNormalizedCacheFactory, enhanceErrorWithDocument };","map":{"version":3,"names":["haveWarned","shouldWarn","answer","isTest","HeuristicFragmentMatcher","prototype","ensureReady","Promise","resolve","canBypassInit","match","idValue","typeCondition","context","obj","store","get","id","isRootQuery","_a","__typename","process","env","NODE_ENV","invariant","warn","error","IntrospectionFragmentMatcher","options","introspectionQueryResultData","possibleTypesMap","parseIntrospectionResult","isReady","bind","JSON","stringify","implementingTypes","indexOf","introspectionResultData","typeMap","__schema","types","forEach","type","kind","name","possibleTypes","map","implementingType","hasOwn","Object","hasOwnProperty","DepTrackingCache","data","_this","create","depend","wrap","dataId","disposable","makeCacheKey","toObject","set","value","oldValue","dirty","delete","call","clear","replace","newData","keys","defaultNormalizedCacheFactory","seed","StoreReader","_b","_c","cacheKeyRoot","KeyTrie","canUseWeakMap","_d","freezeResults","_e","executeStoreQuery","executeSelectionSet","executeSubSelectedArray","query","rootValue","contextValue","variableValues","fragmentMatcher","lookup","selectionSet","execContext","field","array","readQueryFromStore","diffQueryAgainstStore","__assign","returnPartialData","result","variables","previousResult","rootId","fragmentMatcherFunction","config","queryDefinition","getQueryDefinition","assign","getDefaultValues","dataIdFromObject","cacheRedirects","execResult","generated","typename","hasMissingFields","missing","length","info","tolerable","InvariantError","fieldName","object","isEqual","complete","defaultFragmentMatcher","mainDefinition","getMainDefinition","fragments","getFragmentDefinitions","fragmentMap","createFragmentMap","finalResult","objectsToMerge","handleMissing","push","apply","selections","selection","shouldInclude","isField","fieldResult","executeField","resultKeyNameFromField","fragment","isInlineFragment","fragmentExecResult","mergeDeepArray","freeze","args","argumentsObjectFromField","resultKey","directives","getDirectiveInfoFromField","readStoreResult","readStoreResolver","Array","isArray","combineExecResults","assertSelectionSetForIdValue","maybeDeepFreeze","execResults","_i","arguments","pop","childResult","item","isIdValue","assertIdValue","storeKeyName","getStoreKeyName","fieldValue","resolver","getCacheKey","storeObj","toIdValue","isJsonValue","json","ObjectCache","defaultNormalizedCacheFactory$1","__extends","WriteError","_super","Error","enhanceErrorWithDocument","document","enhancedError","message","stack","StoreWriter","writeQueryToStore","writeResultToStore","operationDefinition","getOperationDefinition","writeSelectionSetToStore","processedData","e","resultFieldKey","writeFieldToStore","isDefered","isClient","some","directive","substring","matches","undefined","fakeContext","isProduction","storeValue","storeObject","storeFieldName","storeKeyNameFromField","generatedId","processArrayValue","valueDataId","isGeneratedId","semanticId","isDataProcessed","escapedId","hadTypename","hasTypename","typenameChanged","mergeWithGenerated","index","itemDataId","generatedKey","realKey","cache","real","madeChanges","key","realValue","newRealValue","defaultConfig","defaultDataIdFromObject","addTypename","resultCaching","_id","hasOwn$1","OptimisticCacheLayer","optimisticId","parent","transaction","InMemoryCache","watches","Set","typenameDocumentCache","Map","silenceBroadcast","customResolvers","cacheResolvers","optimisticData","storeWriter","storeReader","maybeBroadcastWatch","c","optimistic","restore","extract","read","transformDocument","write","broadcastWatches","diff","watch","add","evict","reset","removeOptimistic","idToRemove","toReapply","removedCount","layer","layer_1","performTransaction","recordOptimisticTransaction","addTypenameToDocument","callback","ApolloCache"],"sources":["../src/fragmentMatcher.ts","../src/depTrackingCache.ts","../src/readFromStore.ts","../src/objectCache.ts","../src/writeToStore.ts","../src/inMemoryCache.ts"],"sourcesContent":["import { isTest, IdValue } from 'apollo-utilities';\nimport { invariant } from 'ts-invariant';\n\nimport {\n  ReadStoreContext,\n  FragmentMatcherInterface,\n  PossibleTypesMap,\n  IntrospectionResultData,\n} from './types';\n\nlet haveWarned = false;\n\nfunction shouldWarn() {\n  const answer = !haveWarned;\n  /* istanbul ignore if */\n  if (!isTest()) {\n    haveWarned = true;\n  }\n  return answer;\n}\n\n/**\n * This fragment matcher is very basic and unable to match union or interface type conditions\n */\nexport class HeuristicFragmentMatcher implements FragmentMatcherInterface {\n  constructor() {\n    // do nothing\n  }\n\n  public ensureReady() {\n    return Promise.resolve();\n  }\n\n  public canBypassInit() {\n    return true; // we don't need to initialize this fragment matcher.\n  }\n\n  public match(\n    idValue: IdValue,\n    typeCondition: string,\n    context: ReadStoreContext,\n  ): boolean | 'heuristic' {\n    const obj = context.store.get(idValue.id);\n    const isRootQuery = idValue.id === 'ROOT_QUERY';\n\n    if (!obj) {\n      // https://github.com/apollographql/apollo-client/pull/3507\n      return isRootQuery;\n    }\n\n    const { __typename = isRootQuery && 'Query' } = obj;\n\n    if (!__typename) {\n      if (shouldWarn()) {\n        invariant.warn(`You're using fragments in your queries, but either don't have the addTypename:\n  true option set in Apollo Client, or you are trying to write a fragment to the store without the __typename.\n   Please turn on the addTypename option and include __typename when writing fragments so that Apollo Client\n   can accurately match fragments.`);\n        invariant.warn(\n          'Could not find __typename on Fragment ',\n          typeCondition,\n          obj,\n        );\n        invariant.warn(\n          `DEPRECATION WARNING: using fragments without __typename is unsupported behavior ` +\n            `and will be removed in future versions of Apollo client. You should fix this and set addTypename to true now.`,\n        );\n      }\n\n      return 'heuristic';\n    }\n\n    if (__typename === typeCondition) {\n      return true;\n    }\n\n    // At this point we don't know if this fragment should match or not. It's\n    // either:\n    //\n    // 1. (GOOD) A fragment on a matching interface or union.\n    // 2. (BAD) A fragment on a non-matching concrete type or interface or union.\n    //\n    // If it's 2, we don't want it to match. If it's 1, we want it to match. We\n    // can't tell the difference, so we warn the user, but still try to match\n    // it (for backwards compatibility reasons). This unfortunately means that\n    // using the `HeuristicFragmentMatcher` with unions and interfaces is\n    // very unreliable. This will be addressed in a future major version of\n    // Apollo Client, but for now the recommendation is to use the\n    // `IntrospectionFragmentMatcher` when working with unions/interfaces.\n\n    if (shouldWarn()) {\n      invariant.error(\n        'You are using the simple (heuristic) fragment matcher, but your ' +\n          'queries contain union or interface types. Apollo Client will not be ' +\n          'able to accurately map fragments. To make this error go away, use ' +\n          'the `IntrospectionFragmentMatcher` as described in the docs: ' +\n          'https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher',\n      );\n    }\n\n    return 'heuristic';\n  }\n}\n\nexport class IntrospectionFragmentMatcher implements FragmentMatcherInterface {\n  private isReady: boolean;\n  private possibleTypesMap: PossibleTypesMap;\n\n  constructor(options?: {\n    introspectionQueryResultData?: IntrospectionResultData;\n  }) {\n    if (options && options.introspectionQueryResultData) {\n      this.possibleTypesMap = this.parseIntrospectionResult(\n        options.introspectionQueryResultData,\n      );\n      this.isReady = true;\n    } else {\n      this.isReady = false;\n    }\n\n    this.match = this.match.bind(this);\n  }\n\n  public match(\n    idValue: IdValue,\n    typeCondition: string,\n    context: ReadStoreContext,\n  ) {\n    invariant(\n      this.isReady,\n      'FragmentMatcher.match() was called before FragmentMatcher.init()',\n    );\n\n    const obj = context.store.get(idValue.id);\n    const isRootQuery = idValue.id === 'ROOT_QUERY';\n\n    if (!obj) {\n      // https://github.com/apollographql/apollo-client/pull/4620\n      return isRootQuery;\n    }\n\n    const { __typename = isRootQuery && 'Query' } = obj;\n\n    invariant(\n      __typename,\n      `Cannot match fragment because __typename property is missing: ${JSON.stringify(\n        obj,\n      )}`,\n    );\n\n    if (__typename === typeCondition) {\n      return true;\n    }\n\n    const implementingTypes = this.possibleTypesMap[typeCondition];\n    if (\n      __typename &&\n      implementingTypes &&\n      implementingTypes.indexOf(__typename) > -1\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n\n  private parseIntrospectionResult(\n    introspectionResultData: IntrospectionResultData,\n  ): PossibleTypesMap {\n    const typeMap: PossibleTypesMap = {};\n    introspectionResultData.__schema.types.forEach(type => {\n      if (type.kind === 'UNION' || type.kind === 'INTERFACE') {\n        typeMap[type.name] = type.possibleTypes.map(\n          implementingType => implementingType.name,\n        );\n      }\n    });\n    return typeMap;\n  }\n}\n","import { NormalizedCache, NormalizedCacheObject, StoreObject } from './types';\nimport { wrap, OptimisticWrapperFunction } from 'optimism';\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\nexport class DepTrackingCache implements NormalizedCache {\n  // Wrapper function produced by the optimism library, used to depend on\n  // dataId strings, for easy invalidation of specific IDs.\n  private depend: OptimisticWrapperFunction<[string], StoreObject | undefined>;\n\n  constructor(private data: NormalizedCacheObject = Object.create(null)) {\n    this.depend = wrap((dataId: string) => this.data[dataId], {\n      disposable: true,\n      makeCacheKey(dataId: string) {\n        return dataId;\n      },\n    });\n  }\n\n  public toObject(): NormalizedCacheObject {\n    return this.data;\n  }\n\n  public get(dataId: string): StoreObject {\n    this.depend(dataId);\n    return this.data[dataId]!;\n  }\n\n  public set(dataId: string, value?: StoreObject) {\n    const oldValue = this.data[dataId];\n    if (value !== oldValue) {\n      this.data[dataId] = value;\n      this.depend.dirty(dataId);\n    }\n  }\n\n  public delete(dataId: string): void {\n    if (hasOwn.call(this.data, dataId)) {\n      delete this.data[dataId];\n      this.depend.dirty(dataId);\n    }\n  }\n\n  public clear(): void {\n    this.replace(null);\n  }\n\n  public replace(newData: NormalizedCacheObject | null): void {\n    if (newData) {\n      Object.keys(newData).forEach(dataId => {\n        this.set(dataId, newData[dataId]);\n      });\n      Object.keys(this.data).forEach(dataId => {\n        if (!hasOwn.call(newData, dataId)) {\n          this.delete(dataId);\n        }\n      });\n    } else {\n      Object.keys(this.data).forEach(dataId => {\n        this.delete(dataId);\n      });\n    }\n  }\n}\n\nexport function defaultNormalizedCacheFactory(\n  seed?: NormalizedCacheObject,\n): NormalizedCache {\n  return new DepTrackingCache(seed);\n}\n","import {\n  argumentsObjectFromField,\n  assign,\n  canUseWeakMap,\n  createFragmentMap,\n  DirectiveInfo,\n  FragmentMap,\n  getDefaultValues,\n  getDirectiveInfoFromField,\n  getFragmentDefinitions,\n  getMainDefinition,\n  getQueryDefinition,\n  getStoreKeyName,\n  IdValue,\n  isEqual,\n  isField,\n  isIdValue,\n  isInlineFragment,\n  isJsonValue,\n  maybeDeepFreeze,\n  mergeDeepArray,\n  resultKeyNameFromField,\n  shouldInclude,\n  StoreValue,\n  toIdValue,\n} from 'apollo-utilities';\n\nimport { Cache } from 'apollo-cache';\n\nimport {\n  ReadStoreContext,\n  DiffQueryAgainstStoreOptions,\n  ReadQueryOptions,\n  StoreObject,\n} from './types';\n\nimport {\n  DocumentNode,\n  FieldNode,\n  FragmentDefinitionNode,\n  InlineFragmentNode,\n  SelectionSetNode,\n} from 'graphql';\n\nimport { wrap, KeyTrie } from 'optimism';\nimport { DepTrackingCache } from './depTrackingCache';\nimport { invariant, InvariantError } from 'ts-invariant';\n\nexport type VariableMap = { [name: string]: any };\n\nexport type FragmentMatcher = (\n  rootValue: any,\n  typeCondition: string,\n  context: ReadStoreContext,\n) => boolean | 'heuristic';\n\ntype ExecContext = {\n  query: DocumentNode;\n  fragmentMap: FragmentMap;\n  contextValue: ReadStoreContext;\n  variableValues: VariableMap;\n  fragmentMatcher: FragmentMatcher;\n};\n\ntype ExecInfo = {\n  resultKey: string;\n  directives: DirectiveInfo;\n};\n\nexport type ExecResultMissingField = {\n  object: StoreObject;\n  fieldName: string;\n  tolerable: boolean;\n};\n\nexport type ExecResult<R = any> = {\n  result: R;\n  // Empty array if no missing fields encountered while computing result.\n  missing?: ExecResultMissingField[];\n};\n\ntype ExecStoreQueryOptions = {\n  query: DocumentNode;\n  rootValue: IdValue;\n  contextValue: ReadStoreContext;\n  variableValues: VariableMap;\n  // Default matcher always matches all fragments\n  fragmentMatcher?: FragmentMatcher;\n};\n\ntype ExecSelectionSetOptions = {\n  selectionSet: SelectionSetNode;\n  rootValue: any;\n  execContext: ExecContext;\n};\n\ntype ExecSubSelectedArrayOptions = {\n  field: FieldNode;\n  array: any[];\n  execContext: ExecContext;\n};\n\nexport interface StoreReaderConfig {\n  cacheKeyRoot?: KeyTrie<object>;\n  freezeResults?: boolean;\n}\n\nexport class StoreReader {\n  private freezeResults: boolean;\n\n  constructor({\n    cacheKeyRoot = new KeyTrie<object>(canUseWeakMap),\n    freezeResults = false,\n  }: StoreReaderConfig = {}) {\n    const {\n      executeStoreQuery,\n      executeSelectionSet,\n      executeSubSelectedArray,\n    } = this;\n\n    this.freezeResults = freezeResults;\n\n    this.executeStoreQuery = wrap((options: ExecStoreQueryOptions) => {\n      return executeStoreQuery.call(this, options);\n    }, {\n      makeCacheKey({\n        query,\n        rootValue,\n        contextValue,\n        variableValues,\n        fragmentMatcher,\n      }: ExecStoreQueryOptions) {\n        // The result of executeStoreQuery can be safely cached only if the\n        // underlying store is capable of tracking dependencies and invalidating\n        // the cache when relevant data have changed.\n        if (contextValue.store instanceof DepTrackingCache) {\n          return cacheKeyRoot.lookup(\n            contextValue.store,\n            query,\n            fragmentMatcher,\n            JSON.stringify(variableValues),\n            rootValue.id,\n          );\n        }\n      }\n    });\n\n    this.executeSelectionSet = wrap((options: ExecSelectionSetOptions) => {\n      return executeSelectionSet.call(this, options);\n    }, {\n      makeCacheKey({\n        selectionSet,\n        rootValue,\n        execContext,\n      }: ExecSelectionSetOptions) {\n        if (execContext.contextValue.store instanceof DepTrackingCache) {\n          return cacheKeyRoot.lookup(\n            execContext.contextValue.store,\n            selectionSet,\n            execContext.fragmentMatcher,\n            JSON.stringify(execContext.variableValues),\n            rootValue.id,\n          );\n        }\n      }\n    });\n\n    this.executeSubSelectedArray = wrap((options: ExecSubSelectedArrayOptions) => {\n      return executeSubSelectedArray.call(this, options);\n    }, {\n      makeCacheKey({ field, array, execContext }) {\n        if (execContext.contextValue.store instanceof DepTrackingCache) {\n          return cacheKeyRoot.lookup(\n            execContext.contextValue.store,\n            field,\n            array,\n            JSON.stringify(execContext.variableValues),\n          );\n        }\n      }\n    });\n  }\n\n  /**\n   * Resolves the result of a query solely from the store (i.e. never hits the server).\n   *\n   * @param {Store} store The {@link NormalizedCache} used by Apollo for the `data` portion of the\n   * store.\n   *\n   * @param {DocumentNode} query The query document to resolve from the data available in the store.\n   *\n   * @param {Object} [variables] A map from the name of a variable to its value. These variables can\n   * be referenced by the query document.\n   *\n   * @param {any} previousResult The previous result returned by this function for the same query.\n   * If nothing in the store changed since that previous result then values from the previous result\n   * will be returned to preserve referential equality.\n   */\n  public readQueryFromStore<QueryType>(\n    options: ReadQueryOptions,\n  ): QueryType | undefined {\n    return this.diffQueryAgainstStore<QueryType>({\n      ...options,\n      returnPartialData: false,\n    }).result;\n  }\n\n  /**\n   * Given a store and a query, return as much of the result as possible and\n   * identify if any data was missing from the store.\n   * @param  {DocumentNode} query A parsed GraphQL query document\n   * @param  {Store} store The Apollo Client store object\n   * @param  {any} previousResult The previous result returned by this function for the same query\n   * @return {result: Object, complete: [boolean]}\n   */\n  public diffQueryAgainstStore<T>({\n    store,\n    query,\n    variables,\n    previousResult,\n    returnPartialData = true,\n    rootId = 'ROOT_QUERY',\n    fragmentMatcherFunction,\n    config,\n  }: DiffQueryAgainstStoreOptions): Cache.DiffResult<T> {\n    // Throw the right validation error by trying to find a query in the document\n    const queryDefinition = getQueryDefinition(query);\n\n    variables = assign({}, getDefaultValues(queryDefinition), variables);\n\n    const context: ReadStoreContext = {\n      // Global settings\n      store,\n      dataIdFromObject: config && config.dataIdFromObject,\n      cacheRedirects: (config && config.cacheRedirects) || {},\n    };\n\n    const execResult = this.executeStoreQuery({\n      query,\n      rootValue: {\n        type: 'id',\n        id: rootId,\n        generated: true,\n        typename: 'Query',\n      },\n      contextValue: context,\n      variableValues: variables,\n      fragmentMatcher: fragmentMatcherFunction,\n    });\n\n    const hasMissingFields =\n      execResult.missing && execResult.missing.length > 0;\n\n    if (hasMissingFields && ! returnPartialData) {\n      execResult.missing!.forEach(info => {\n        if (info.tolerable) return;\n        throw new InvariantError(\n          `Can't find field ${info.fieldName} on object ${JSON.stringify(\n            info.object,\n            null,\n            2,\n          )}.`,\n        );\n      });\n    }\n\n    if (previousResult) {\n      if (isEqual(previousResult, execResult.result)) {\n        execResult.result = previousResult;\n      }\n    }\n\n    return {\n      result: execResult.result,\n      complete: !hasMissingFields,\n    };\n  }\n\n  /**\n   * Based on graphql function from graphql-js:\n   *\n   * graphql(\n   *   schema: GraphQLSchema,\n   *   requestString: string,\n   *   rootValue?: ?any,\n   *   contextValue?: ?any,\n   *   variableValues?: ?{[key: string]: any},\n   *   operationName?: ?string\n   * ): Promise<GraphQLResult>\n   *\n   * The default export as of graphql-anywhere is sync as of 4.0,\n   * but below is an exported alternative that is async.\n   * In the 5.0 version, this will be the only export again\n   * and it will be async\n   *\n   */\n  private executeStoreQuery({\n    query,\n    rootValue,\n    contextValue,\n    variableValues,\n    // Default matcher always matches all fragments\n    fragmentMatcher = defaultFragmentMatcher,\n  }: ExecStoreQueryOptions): ExecResult {\n    const mainDefinition = getMainDefinition(query);\n    const fragments = getFragmentDefinitions(query);\n    const fragmentMap = createFragmentMap(fragments);\n    const execContext: ExecContext = {\n      query,\n      fragmentMap,\n      contextValue,\n      variableValues,\n      fragmentMatcher,\n    };\n\n    return this.executeSelectionSet({\n      selectionSet: mainDefinition.selectionSet,\n      rootValue,\n      execContext,\n    });\n  }\n\n  private executeSelectionSet({\n    selectionSet,\n    rootValue,\n    execContext,\n  }: ExecSelectionSetOptions): ExecResult {\n    const { fragmentMap, contextValue, variableValues: variables } = execContext;\n    const finalResult: ExecResult = { result: null };\n\n    const objectsToMerge: { [key: string]: any }[] = [];\n\n    const object: StoreObject = contextValue.store.get(rootValue.id);\n\n    const typename =\n      (object && object.__typename) ||\n      (rootValue.id === 'ROOT_QUERY' && 'Query') ||\n      void 0;\n\n    function handleMissing<T>(result: ExecResult<T>): T {\n      if (result.missing) {\n        finalResult.missing = finalResult.missing || [];\n        finalResult.missing.push(...result.missing);\n      }\n      return result.result;\n    }\n\n    selectionSet.selections.forEach(selection => {\n      if (!shouldInclude(selection, variables)) {\n        // Skip this entirely\n        return;\n      }\n\n      if (isField(selection)) {\n        const fieldResult = handleMissing(\n          this.executeField(object, typename, selection, execContext),\n        );\n\n        if (typeof fieldResult !== 'undefined') {\n          objectsToMerge.push({\n            [resultKeyNameFromField(selection)]: fieldResult,\n          });\n        }\n\n      } else {\n        let fragment: InlineFragmentNode | FragmentDefinitionNode;\n\n        if (isInlineFragment(selection)) {\n          fragment = selection;\n        } else {\n          // This is a named fragment\n          fragment = fragmentMap[selection.name.value];\n\n          if (!fragment) {\n            throw new InvariantError(`No fragment named ${selection.name.value}`);\n          }\n        }\n\n        const typeCondition =\n          fragment.typeCondition && fragment.typeCondition.name.value;\n\n        const match =\n          !typeCondition ||\n          execContext.fragmentMatcher(rootValue, typeCondition, contextValue);\n\n        if (match) {\n          let fragmentExecResult = this.executeSelectionSet({\n            selectionSet: fragment.selectionSet,\n            rootValue,\n            execContext,\n          });\n\n          if (match === 'heuristic' && fragmentExecResult.missing) {\n            fragmentExecResult = {\n              ...fragmentExecResult,\n              missing: fragmentExecResult.missing.map(info => {\n                return { ...info, tolerable: true };\n              }),\n            };\n          }\n\n          objectsToMerge.push(handleMissing(fragmentExecResult));\n        }\n      }\n    });\n\n    // Perform a single merge at the end so that we can avoid making more\n    // defensive shallow copies than necessary.\n    finalResult.result = mergeDeepArray(objectsToMerge);\n\n    if (this.freezeResults && process.env.NODE_ENV !== 'production') {\n      Object.freeze(finalResult.result);\n    }\n\n    return finalResult;\n  }\n\n  private executeField(\n    object: StoreObject,\n    typename: string | void,\n    field: FieldNode,\n    execContext: ExecContext,\n  ): ExecResult {\n    const { variableValues: variables, contextValue } = execContext;\n    const fieldName = field.name.value;\n    const args = argumentsObjectFromField(field, variables);\n\n    const info: ExecInfo = {\n      resultKey: resultKeyNameFromField(field),\n      directives: getDirectiveInfoFromField(field, variables),\n    };\n\n    const readStoreResult = readStoreResolver(\n      object,\n      typename,\n      fieldName,\n      args,\n      contextValue,\n      info,\n    );\n\n    if (Array.isArray(readStoreResult.result)) {\n      return this.combineExecResults(\n        readStoreResult,\n        this.executeSubSelectedArray({\n          field,\n          array: readStoreResult.result,\n          execContext,\n        }),\n      );\n    }\n\n    // Handle all scalar types here\n    if (!field.selectionSet) {\n      assertSelectionSetForIdValue(field, readStoreResult.result);\n      if (this.freezeResults && process.env.NODE_ENV !== 'production') {\n        maybeDeepFreeze(readStoreResult);\n      }\n      return readStoreResult;\n    }\n\n    // From here down, the field has a selection set, which means it's trying to\n    // query a GraphQLObjectType\n    if (readStoreResult.result == null) {\n      // Basically any field in a GraphQL response can be null, or missing\n      return readStoreResult;\n    }\n\n    // Returned value is an object, and the query has a sub-selection. Recurse.\n    return this.combineExecResults(\n      readStoreResult,\n      this.executeSelectionSet({\n        selectionSet: field.selectionSet,\n        rootValue: readStoreResult.result,\n        execContext,\n      }),\n    );\n  }\n\n  private combineExecResults<T>(\n    ...execResults: ExecResult<T>[]\n  ): ExecResult<T> {\n    let missing: ExecResultMissingField[] | undefined;\n    execResults.forEach(execResult => {\n      if (execResult.missing) {\n        missing = missing || [];\n        missing.push(...execResult.missing);\n      }\n    });\n    return {\n      result: execResults.pop()!.result,\n      missing,\n    };\n  }\n\n  private executeSubSelectedArray({\n    field,\n    array,\n    execContext,\n  }: ExecSubSelectedArrayOptions): ExecResult {\n    let missing: ExecResultMissingField[] | undefined;\n\n    function handleMissing<T>(childResult: ExecResult<T>): T {\n      if (childResult.missing) {\n        missing = missing || [];\n        missing.push(...childResult.missing);\n      }\n\n      return childResult.result;\n    }\n\n    array = array.map(item => {\n      // null value in array\n      if (item === null) {\n        return null;\n      }\n\n      // This is a nested array, recurse\n      if (Array.isArray(item)) {\n        return handleMissing(this.executeSubSelectedArray({\n          field,\n          array: item,\n          execContext,\n        }));\n      }\n\n      // This is an object, run the selection set on it\n      if (field.selectionSet) {\n        return handleMissing(this.executeSelectionSet({\n          selectionSet: field.selectionSet,\n          rootValue: item,\n          execContext,\n        }));\n      }\n\n      assertSelectionSetForIdValue(field, item);\n\n      return item;\n    });\n\n    if (this.freezeResults && process.env.NODE_ENV !== 'production') {\n      Object.freeze(array);\n    }\n\n    return { result: array, missing };\n  }\n}\n\nfunction assertSelectionSetForIdValue(\n  field: FieldNode,\n  value: any,\n) {\n  if (!field.selectionSet && isIdValue(value)) {\n    throw new InvariantError(\n      `Missing selection set for object of type ${\n        value.typename\n      } returned for query field ${field.name.value}`\n    );\n  }\n}\n\nfunction defaultFragmentMatcher() {\n  return true;\n}\n\nexport function assertIdValue(idValue: IdValue) {\n  invariant(isIdValue(idValue), `\\\nEncountered a sub-selection on the query, but the store doesn't have \\\nan object reference. This should never happen during normal use unless you have custom code \\\nthat is directly manipulating the store; please file an issue.`);\n}\n\nfunction readStoreResolver(\n  object: StoreObject,\n  typename: string | void,\n  fieldName: string,\n  args: any,\n  context: ReadStoreContext,\n  { resultKey, directives }: ExecInfo,\n): ExecResult<StoreValue> {\n  let storeKeyName = fieldName;\n  if (args || directives) {\n    // We happen to know here that getStoreKeyName returns its first\n    // argument unmodified if there are no args or directives, so we can\n    // avoid calling the function at all in that case, as a small but\n    // important optimization to this frequently executed code.\n    storeKeyName = getStoreKeyName(storeKeyName, args, directives);\n  }\n\n  let fieldValue: StoreValue | void = void 0;\n\n  if (object) {\n    fieldValue = object[storeKeyName];\n\n    if (\n      typeof fieldValue === 'undefined' &&\n      context.cacheRedirects &&\n      typeof typename === 'string'\n    ) {\n      // Look for the type in the custom resolver map\n      const type = context.cacheRedirects[typename];\n      if (type) {\n        // Look for the field in the custom resolver map\n        const resolver = type[fieldName];\n        if (resolver) {\n          fieldValue = resolver(object, args, {\n            getCacheKey(storeObj: StoreObject) {\n              const id = context.dataIdFromObject!(storeObj);\n              return id && toIdValue({\n                id,\n                typename: storeObj.__typename,\n              });\n            },\n          });\n        }\n      }\n    }\n  }\n\n  if (typeof fieldValue === 'undefined') {\n    return {\n      result: fieldValue,\n      missing: [{\n        object,\n        fieldName: storeKeyName,\n        tolerable: false,\n      }],\n    };\n  }\n\n  if (isJsonValue(fieldValue)) {\n    fieldValue = fieldValue.json;\n  }\n\n  return {\n    result: fieldValue,\n  };\n}\n","import { NormalizedCache, NormalizedCacheObject, StoreObject } from './types';\n\nexport class ObjectCache implements NormalizedCache {\n  constructor(protected data: NormalizedCacheObject = Object.create(null)) {}\n\n  public toObject() {\n    return this.data;\n  }\n\n  public get(dataId: string) {\n    return this.data[dataId]!;\n  }\n\n  public set(dataId: string, value: StoreObject) {\n    this.data[dataId] = value;\n  }\n\n  public delete(dataId: string) {\n    this.data[dataId] = void 0;\n  }\n\n  public clear() {\n    this.data = Object.create(null);\n  }\n\n  public replace(newData: NormalizedCacheObject) {\n    this.data = newData || Object.create(null);\n  }\n}\n\nexport function defaultNormalizedCacheFactory(\n  seed?: NormalizedCacheObject,\n): NormalizedCache {\n  return new ObjectCache(seed);\n}\n","import {\n  SelectionSetNode,\n  FieldNode,\n  DocumentNode,\n  InlineFragmentNode,\n  FragmentDefinitionNode,\n} from 'graphql';\nimport { FragmentMatcher } from './readFromStore';\n\nimport {\n  assign,\n  createFragmentMap,\n  FragmentMap,\n  getDefaultValues,\n  getFragmentDefinitions,\n  getOperationDefinition,\n  IdValue,\n  isField,\n  isIdValue,\n  isInlineFragment,\n  isProduction,\n  resultKeyNameFromField,\n  shouldInclude,\n  storeKeyNameFromField,\n  StoreValue,\n  toIdValue,\n  isEqual,\n} from 'apollo-utilities';\n\nimport { invariant } from 'ts-invariant';\n\nimport { ObjectCache } from './objectCache';\nimport { defaultNormalizedCacheFactory } from './depTrackingCache';\n\nimport {\n  IdGetter,\n  NormalizedCache,\n  ReadStoreContext,\n  StoreObject,\n} from './types';\n\nexport class WriteError extends Error {\n  public type = 'WriteError';\n}\n\nexport function enhanceErrorWithDocument(error: Error, document: DocumentNode) {\n  // XXX A bit hacky maybe ...\n  const enhancedError = new WriteError(\n    `Error writing result to store for query:\\n ${JSON.stringify(document)}`,\n  );\n  enhancedError.message += '\\n' + error.message;\n  enhancedError.stack = error.stack;\n  return enhancedError;\n}\n\nexport type WriteContext = {\n  readonly store: NormalizedCache;\n  readonly processedData?: { [x: string]: FieldNode[] };\n  readonly variables?: any;\n  readonly dataIdFromObject?: IdGetter;\n  readonly fragmentMap?: FragmentMap;\n  readonly fragmentMatcherFunction?: FragmentMatcher;\n};\n\nexport class StoreWriter {\n  /**\n   * Writes the result of a query to the store.\n   *\n   * @param result The result object returned for the query document.\n   *\n   * @param query The query document whose result we are writing to the store.\n   *\n   * @param store The {@link NormalizedCache} used by Apollo for the `data` portion of the store.\n   *\n   * @param variables A map from the name of a variable to its value. These variables can be\n   * referenced by the query document.\n   *\n   * @param dataIdFromObject A function that returns an object identifier given a particular result\n   * object. See the store documentation for details and an example of this function.\n   *\n   * @param fragmentMatcherFunction A function to use for matching fragment conditions in GraphQL documents\n   */\n  public writeQueryToStore({\n    query,\n    result,\n    store = defaultNormalizedCacheFactory(),\n    variables,\n    dataIdFromObject,\n    fragmentMatcherFunction,\n  }: {\n    query: DocumentNode;\n    result: Object;\n    store?: NormalizedCache;\n    variables?: Object;\n    dataIdFromObject?: IdGetter;\n    fragmentMatcherFunction?: FragmentMatcher;\n  }): NormalizedCache {\n    return this.writeResultToStore({\n      dataId: 'ROOT_QUERY',\n      result,\n      document: query,\n      store,\n      variables,\n      dataIdFromObject,\n      fragmentMatcherFunction,\n    });\n  }\n\n  public writeResultToStore({\n    dataId,\n    result,\n    document,\n    store = defaultNormalizedCacheFactory(),\n    variables,\n    dataIdFromObject,\n    fragmentMatcherFunction,\n  }: {\n    dataId: string;\n    result: any;\n    document: DocumentNode;\n    store?: NormalizedCache;\n    variables?: Object;\n    dataIdFromObject?: IdGetter;\n    fragmentMatcherFunction?: FragmentMatcher;\n  }): NormalizedCache {\n    // XXX TODO REFACTOR: this is a temporary workaround until query normalization is made to work with documents.\n    const operationDefinition = getOperationDefinition(document)!;\n\n    try {\n      return this.writeSelectionSetToStore({\n        result,\n        dataId,\n        selectionSet: operationDefinition.selectionSet,\n        context: {\n          store,\n          processedData: {},\n          variables: assign(\n            {},\n            getDefaultValues(operationDefinition),\n            variables,\n          ),\n          dataIdFromObject,\n          fragmentMap: createFragmentMap(getFragmentDefinitions(document)),\n          fragmentMatcherFunction,\n        },\n      });\n    } catch (e) {\n      throw enhanceErrorWithDocument(e, document);\n    }\n  }\n\n  public writeSelectionSetToStore({\n    result,\n    dataId,\n    selectionSet,\n    context,\n  }: {\n    dataId: string;\n    result: any;\n    selectionSet: SelectionSetNode;\n    context: WriteContext;\n  }): NormalizedCache {\n    const { variables, store, fragmentMap } = context;\n\n    selectionSet.selections.forEach(selection => {\n      if (!shouldInclude(selection, variables)) {\n        return;\n      }\n\n      if (isField(selection)) {\n        const resultFieldKey: string = resultKeyNameFromField(selection);\n        const value: any = result[resultFieldKey];\n\n        if (typeof value !== 'undefined') {\n          this.writeFieldToStore({\n            dataId,\n            value,\n            field: selection,\n            context,\n          });\n        } else {\n          let isDefered = false;\n          let isClient = false;\n          if (selection.directives && selection.directives.length) {\n            // If this is a defered field we don't need to throw / warn.\n            isDefered = selection.directives.some(\n              directive => directive.name && directive.name.value === 'defer',\n            );\n\n            // When using the @client directive, it might be desirable in\n            // some cases to want to write a selection set to the store,\n            // without having all of the selection set values available.\n            // This is because the @client field values might have already\n            // been written to the cache separately (e.g. via Apollo\n            // Cache's `writeData` capabilities). Because of this, we'll\n            // skip the missing field warning for fields with @client\n            // directives.\n            isClient = selection.directives.some(\n              directive => directive.name && directive.name.value === 'client',\n            );\n          }\n\n          if (!isDefered && !isClient && context.fragmentMatcherFunction) {\n            // XXX We'd like to throw an error, but for backwards compatibility's sake\n            // we just print a warning for the time being.\n            //throw new WriteError(`Missing field ${resultFieldKey} in ${JSON.stringify(result, null, 2).substring(0, 100)}`);\n            invariant.warn(\n              `Missing field ${resultFieldKey} in ${JSON.stringify(\n                result,\n                null,\n                2,\n              ).substring(0, 100)}`,\n            );\n          }\n        }\n      } else {\n        // This is not a field, so it must be a fragment, either inline or named\n        let fragment: InlineFragmentNode | FragmentDefinitionNode;\n\n        if (isInlineFragment(selection)) {\n          fragment = selection;\n        } else {\n          // Named fragment\n          fragment = (fragmentMap || {})[selection.name.value];\n          invariant(fragment, `No fragment named ${selection.name.value}.`);\n        }\n\n        let matches = true;\n        if (context.fragmentMatcherFunction && fragment.typeCondition) {\n          // TODO we need to rewrite the fragment matchers for this to work properly and efficiently\n          // Right now we have to pretend that we're passing in an idValue and that there's a store\n          // on the context.\n          const id = dataId || 'self';\n          const idValue = toIdValue({ id, typename: undefined });\n          const fakeContext: ReadStoreContext = {\n            // NOTE: fakeContext always uses ObjectCache\n            // since this is only to ensure the return value of 'matches'\n            store: new ObjectCache({ [id]: result }),\n            cacheRedirects: {},\n          };\n          const match = context.fragmentMatcherFunction(\n            idValue,\n            fragment.typeCondition.name.value,\n            fakeContext,\n          );\n          if (!isProduction() && match === 'heuristic') {\n            invariant.error('WARNING: heuristic fragment matching going on!');\n          }\n          matches = !!match;\n        }\n\n        if (matches) {\n          this.writeSelectionSetToStore({\n            result,\n            selectionSet: fragment.selectionSet,\n            dataId,\n            context,\n          });\n        }\n      }\n    });\n\n    return store;\n  }\n\n  private writeFieldToStore({\n    field,\n    value,\n    dataId,\n    context,\n  }: {\n    field: FieldNode;\n    value: any;\n    dataId: string;\n    context: WriteContext;\n  }) {\n    const { variables, dataIdFromObject, store } = context;\n\n    let storeValue: StoreValue;\n    let storeObject: StoreObject;\n\n    const storeFieldName: string = storeKeyNameFromField(field, variables);\n\n    // If this is a scalar value...\n    if (!field.selectionSet || value === null) {\n      storeValue =\n        value != null && typeof value === 'object'\n          ? // If the scalar value is a JSON blob, we have to \"escape\" it so it cant pretend to be\n            // an id.\n            { type: 'json', json: value }\n          : // Otherwise, just store the scalar directly in the store.\n            value;\n    } else if (Array.isArray(value)) {\n      const generatedId = `${dataId}.${storeFieldName}`;\n\n      storeValue = this.processArrayValue(\n        value,\n        generatedId,\n        field.selectionSet,\n        context,\n      );\n    } else {\n      // It's an object\n      let valueDataId = `${dataId}.${storeFieldName}`;\n      let generated = true;\n\n      // We only prepend the '$' if the valueDataId isn't already a generated\n      // id.\n      if (!isGeneratedId(valueDataId)) {\n        valueDataId = '$' + valueDataId;\n      }\n\n      if (dataIdFromObject) {\n        const semanticId = dataIdFromObject(value);\n\n        // We throw an error if the first character of the id is '$. This is\n        // because we use that character to designate an Apollo-generated id\n        // and we use the distinction between user-desiginated and application-provided\n        // ids when managing overwrites.\n        invariant(\n          !semanticId || !isGeneratedId(semanticId),\n          'IDs returned by dataIdFromObject cannot begin with the \"$\" character.',\n        );\n\n        if (\n          semanticId ||\n          (typeof semanticId === 'number' && semanticId === 0)\n        ) {\n          valueDataId = semanticId;\n          generated = false;\n        }\n      }\n\n      if (!isDataProcessed(valueDataId, field, context.processedData)) {\n        this.writeSelectionSetToStore({\n          dataId: valueDataId,\n          result: value,\n          selectionSet: field.selectionSet,\n          context,\n        });\n      }\n\n      // We take the id and escape it (i.e. wrap it with an enclosing object).\n      // This allows us to distinguish IDs from normal scalars.\n      const typename = value.__typename;\n      storeValue = toIdValue({ id: valueDataId, typename }, generated);\n\n      // check if there was a generated id at the location where we're\n      // about to place this new id. If there was, we have to merge the\n      // data from that id with the data we're about to write in the store.\n      storeObject = store.get(dataId);\n      const escapedId =\n        storeObject && (storeObject[storeFieldName] as IdValue | undefined);\n      if (escapedId !== storeValue && isIdValue(escapedId)) {\n        const hadTypename = escapedId.typename !== undefined;\n        const hasTypename = typename !== undefined;\n        const typenameChanged =\n          hadTypename && hasTypename && escapedId.typename !== typename;\n\n        // If there is already a real id in the store and the current id we\n        // are dealing with is generated, we throw an error.\n        // One exception we allow is when the typename has changed, which occurs\n        // when schema defines a union, both with and without an ID in the same place.\n        // checks if we \"lost\" the read id\n        invariant(\n          !generated || escapedId.generated || typenameChanged,\n          `Store error: the application attempted to write an object with no provided id but the store already contains an id of ${\n            escapedId.id\n          } for this object. The selectionSet that was trying to be written is:\\n${\n            JSON.stringify(field)\n          }`,\n        );\n\n        // checks if we \"lost\" the typename\n        invariant(\n          !hadTypename || hasTypename,\n          `Store error: the application attempted to write an object with no provided typename but the store already contains an object with typename of ${\n            escapedId.typename\n          } for the object of id ${escapedId.id}. The selectionSet that was trying to be written is:\\n${\n            JSON.stringify(field)\n          }`,\n        );\n\n        if (escapedId.generated) {\n          // We should only merge if it's an object of the same type,\n          // otherwise we should delete the generated object\n          if (typenameChanged) {\n            // Only delete the generated object when the old object was\n            // inlined, and the new object is not. This is indicated by\n            // the old id being generated, and the new id being real.\n            if (!generated) {\n              store.delete(escapedId.id);\n            }\n          } else {\n            mergeWithGenerated(escapedId.id, (storeValue as IdValue).id, store);\n          }\n        }\n      }\n    }\n\n    storeObject = store.get(dataId);\n    if (!storeObject || !isEqual(storeValue, storeObject[storeFieldName])) {\n      store.set(dataId, {\n        ...storeObject,\n        [storeFieldName]: storeValue,\n      });\n    }\n  }\n\n  private processArrayValue(\n    value: any[],\n    generatedId: string,\n    selectionSet: SelectionSetNode,\n    context: WriteContext,\n  ): any[] {\n    return value.map((item: any, index: any) => {\n      if (item === null) {\n        return null;\n      }\n\n      let itemDataId = `${generatedId}.${index}`;\n\n      if (Array.isArray(item)) {\n        return this.processArrayValue(item, itemDataId, selectionSet, context);\n      }\n\n      let generated = true;\n\n      if (context.dataIdFromObject) {\n        const semanticId = context.dataIdFromObject(item);\n\n        if (semanticId) {\n          itemDataId = semanticId;\n          generated = false;\n        }\n      }\n\n      if (!isDataProcessed(itemDataId, selectionSet, context.processedData)) {\n        this.writeSelectionSetToStore({\n          dataId: itemDataId,\n          result: item,\n          selectionSet,\n          context,\n        });\n      }\n\n      return toIdValue(\n        { id: itemDataId, typename: item.__typename },\n        generated,\n      );\n    });\n  }\n}\n\n// Checks if the id given is an id that was generated by Apollo\n// rather than by dataIdFromObject.\nfunction isGeneratedId(id: string): boolean {\n  return id[0] === '$';\n}\n\nfunction mergeWithGenerated(\n  generatedKey: string,\n  realKey: string,\n  cache: NormalizedCache,\n): boolean {\n  if (generatedKey === realKey) {\n    return false;\n  }\n\n  const generated = cache.get(generatedKey);\n  const real = cache.get(realKey);\n  let madeChanges = false;\n\n  Object.keys(generated).forEach(key => {\n    const value = generated[key];\n    const realValue = real[key];\n\n    if (\n      isIdValue(value) &&\n      isGeneratedId(value.id) &&\n      isIdValue(realValue) &&\n      !isEqual(value, realValue) &&\n      mergeWithGenerated(value.id, realValue.id, cache)\n    ) {\n      madeChanges = true;\n    }\n  });\n\n  cache.delete(generatedKey);\n  const newRealValue = { ...generated, ...real };\n\n  if (isEqual(newRealValue, real)) {\n    return madeChanges;\n  }\n\n  cache.set(realKey, newRealValue);\n  return true;\n}\n\nfunction isDataProcessed(\n  dataId: string,\n  field: FieldNode | SelectionSetNode,\n  processedData?: { [x: string]: (FieldNode | SelectionSetNode)[] },\n): boolean {\n  if (!processedData) {\n    return false;\n  }\n\n  if (processedData[dataId]) {\n    if (processedData[dataId].indexOf(field) >= 0) {\n      return true;\n    } else {\n      processedData[dataId].push(field);\n    }\n  } else {\n    processedData[dataId] = [field];\n  }\n\n  return false;\n}\n","// Make builtins like Map and Set safe to use with non-extensible objects.\nimport './fixPolyfills';\n\nimport { DocumentNode } from 'graphql';\n\nimport { Cache, ApolloCache, Transaction } from 'apollo-cache';\n\nimport { addTypenameToDocument, canUseWeakMap } from 'apollo-utilities';\n\nimport { wrap } from 'optimism';\n\nimport { invariant, InvariantError } from 'ts-invariant';\n\nimport { HeuristicFragmentMatcher } from './fragmentMatcher';\nimport {\n  ApolloReducerConfig,\n  NormalizedCache,\n  NormalizedCacheObject,\n} from './types';\n\nimport { StoreReader } from './readFromStore';\nimport { StoreWriter } from './writeToStore';\nimport { DepTrackingCache } from './depTrackingCache';\nimport { KeyTrie } from 'optimism';\nimport { ObjectCache } from './objectCache';\n\nexport interface InMemoryCacheConfig extends ApolloReducerConfig {\n  resultCaching?: boolean;\n  freezeResults?: boolean;\n}\n\nconst defaultConfig: InMemoryCacheConfig = {\n  fragmentMatcher: new HeuristicFragmentMatcher(),\n  dataIdFromObject: defaultDataIdFromObject,\n  addTypename: true,\n  resultCaching: true,\n  freezeResults: false,\n};\n\nexport function defaultDataIdFromObject(result: any): string | null {\n  if (result.__typename) {\n    if (result.id !== undefined) {\n      return `${result.__typename}:${result.id}`;\n    }\n    if (result._id !== undefined) {\n      return `${result.__typename}:${result._id}`;\n    }\n  }\n  return null;\n}\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\nexport class OptimisticCacheLayer extends ObjectCache {\n  constructor(\n    public readonly optimisticId: string,\n    // OptimisticCacheLayer objects always wrap some other parent cache, so\n    // this.parent should never be null.\n    public readonly parent: NormalizedCache,\n    public readonly transaction: Transaction<NormalizedCacheObject>,\n  ) {\n    super(Object.create(null));\n  }\n\n  public toObject(): NormalizedCacheObject {\n    return {\n      ...this.parent.toObject(),\n      ...this.data,\n    };\n  }\n\n  // All the other accessor methods of ObjectCache work without knowing about\n  // this.parent, but the get method needs to be overridden to implement the\n  // fallback this.parent.get(dataId) behavior.\n  public get(dataId: string) {\n    return hasOwn.call(this.data, dataId)\n      ? this.data[dataId]\n      : this.parent.get(dataId);\n  }\n}\n\nexport class InMemoryCache extends ApolloCache<NormalizedCacheObject> {\n  private data: NormalizedCache;\n  private optimisticData: NormalizedCache;\n\n  protected config: InMemoryCacheConfig;\n  private watches = new Set<Cache.WatchOptions>();\n  private addTypename: boolean;\n  private typenameDocumentCache = new Map<DocumentNode, DocumentNode>();\n  private storeReader: StoreReader;\n  private storeWriter: StoreWriter;\n  private cacheKeyRoot = new KeyTrie<object>(canUseWeakMap);\n\n  // Set this while in a transaction to prevent broadcasts...\n  // don't forget to turn it back on!\n  private silenceBroadcast: boolean = false;\n\n  constructor(config: InMemoryCacheConfig = {}) {\n    super();\n    this.config = { ...defaultConfig, ...config };\n\n    // backwards compat\n    if ((this.config as any).customResolvers) {\n      invariant.warn(\n        'customResolvers have been renamed to cacheRedirects. Please update your config as we will be deprecating customResolvers in the next major version.',\n      );\n      this.config.cacheRedirects = (this.config as any).customResolvers;\n    }\n\n    if ((this.config as any).cacheResolvers) {\n      invariant.warn(\n        'cacheResolvers have been renamed to cacheRedirects. Please update your config as we will be deprecating cacheResolvers in the next major version.',\n      );\n      this.config.cacheRedirects = (this.config as any).cacheResolvers;\n    }\n\n    this.addTypename = !!this.config.addTypename;\n\n    // Passing { resultCaching: false } in the InMemoryCache constructor options\n    // will completely disable dependency tracking, which will improve memory\n    // usage but worsen the performance of repeated reads.\n    this.data = this.config.resultCaching\n      ? new DepTrackingCache()\n      : new ObjectCache();\n\n    // When no optimistic writes are currently active, cache.optimisticData ===\n    // cache.data, so there are no additional layers on top of the actual data.\n    // When an optimistic update happens, this.optimisticData will become a\n    // linked list of OptimisticCacheLayer objects that terminates with the\n    // original this.data cache object.\n    this.optimisticData = this.data;\n\n    this.storeWriter = new StoreWriter();\n    this.storeReader = new StoreReader({\n      cacheKeyRoot: this.cacheKeyRoot,\n      freezeResults: config.freezeResults,\n    });\n\n    const cache = this;\n    const { maybeBroadcastWatch } = cache;\n    this.maybeBroadcastWatch = wrap((c: Cache.WatchOptions) => {\n      return maybeBroadcastWatch.call(this, c);\n    }, {\n      makeCacheKey(c: Cache.WatchOptions) {\n        if (c.optimistic) {\n          // If we're reading optimistic data, it doesn't matter if this.data\n          // is a DepTrackingCache, since it will be ignored.\n          return;\n        }\n\n        if (c.previousResult) {\n          // If a previousResult was provided, assume the caller would prefer\n          // to compare the previous data to the new data to determine whether\n          // to broadcast, so we should disable caching by returning here, to\n          // give maybeBroadcastWatch a chance to do that comparison.\n          return;\n        }\n\n        if (cache.data instanceof DepTrackingCache) {\n          // Return a cache key (thus enabling caching) only if we're currently\n          // using a data store that can track cache dependencies.\n          return cache.cacheKeyRoot.lookup(\n            c.query,\n            JSON.stringify(c.variables),\n          );\n        }\n      }\n    });\n  }\n\n  public restore(data: NormalizedCacheObject): this {\n    if (data) this.data.replace(data);\n    return this;\n  }\n\n  public extract(optimistic: boolean = false): NormalizedCacheObject {\n    return (optimistic ? this.optimisticData : this.data).toObject();\n  }\n\n  public read<T>(options: Cache.ReadOptions): T | null {\n    if (typeof options.rootId === 'string' &&\n        typeof this.data.get(options.rootId) === 'undefined') {\n      return null;\n    }\n\n    const { fragmentMatcher } = this.config;\n    const fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;\n\n    return this.storeReader.readQueryFromStore({\n      store: options.optimistic ? this.optimisticData : this.data,\n      query: this.transformDocument(options.query),\n      variables: options.variables,\n      rootId: options.rootId,\n      fragmentMatcherFunction,\n      previousResult: options.previousResult,\n      config: this.config,\n    }) || null;\n  }\n\n  public write(write: Cache.WriteOptions): void {\n    const { fragmentMatcher } = this.config;\n    const fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;\n\n    this.storeWriter.writeResultToStore({\n      dataId: write.dataId,\n      result: write.result,\n      variables: write.variables,\n      document: this.transformDocument(write.query),\n      store: this.data,\n      dataIdFromObject: this.config.dataIdFromObject,\n      fragmentMatcherFunction,\n    });\n\n    this.broadcastWatches();\n  }\n\n  public diff<T>(query: Cache.DiffOptions): Cache.DiffResult<T> {\n    const { fragmentMatcher } = this.config;\n    const fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;\n\n    return this.storeReader.diffQueryAgainstStore({\n      store: query.optimistic ? this.optimisticData : this.data,\n      query: this.transformDocument(query.query),\n      variables: query.variables,\n      returnPartialData: query.returnPartialData,\n      previousResult: query.previousResult,\n      fragmentMatcherFunction,\n      config: this.config,\n    });\n  }\n\n  public watch(watch: Cache.WatchOptions): () => void {\n    this.watches.add(watch);\n\n    return () => {\n      this.watches.delete(watch);\n    };\n  }\n\n  public evict(query: Cache.EvictOptions): Cache.EvictionResult {\n    throw new InvariantError(`eviction is not implemented on InMemory Cache`);\n  }\n\n  public reset(): Promise<void> {\n    this.data.clear();\n    this.broadcastWatches();\n\n    return Promise.resolve();\n  }\n\n  public removeOptimistic(idToRemove: string) {\n    const toReapply: OptimisticCacheLayer[] = [];\n    let removedCount = 0;\n    let layer = this.optimisticData;\n\n    while (layer instanceof OptimisticCacheLayer) {\n      if (layer.optimisticId === idToRemove) {\n        ++removedCount;\n      } else {\n        toReapply.push(layer);\n      }\n      layer = layer.parent;\n    }\n\n    if (removedCount > 0) {\n      // Reset this.optimisticData to the first non-OptimisticCacheLayer object,\n      // which is almost certainly this.data.\n      this.optimisticData = layer;\n\n      // Reapply the layers whose optimistic IDs do not match the removed ID.\n      while (toReapply.length > 0) {\n        const layer = toReapply.pop()!;\n        this.performTransaction(layer.transaction, layer.optimisticId);\n      }\n\n      this.broadcastWatches();\n    }\n  }\n\n  public performTransaction(\n    transaction: Transaction<NormalizedCacheObject>,\n    // This parameter is not part of the performTransaction signature inherited\n    // from the ApolloCache abstract class, but it's useful because it saves us\n    // from duplicating this implementation in recordOptimisticTransaction.\n    optimisticId?: string,\n  ) {\n    const { data, silenceBroadcast } = this;\n    this.silenceBroadcast = true;\n\n    if (typeof optimisticId === 'string') {\n      // Add a new optimistic layer and temporarily make this.data refer to\n      // that layer for the duration of the transaction.\n      this.data = this.optimisticData = new OptimisticCacheLayer(\n        // Note that there can be multiple layers with the same optimisticId.\n        // When removeOptimistic(id) is called for that id, all matching layers\n        // will be removed, and the remaining layers will be reapplied.\n        optimisticId,\n        this.optimisticData,\n        transaction,\n      );\n    }\n\n    try {\n      transaction(this);\n    } finally {\n      this.silenceBroadcast = silenceBroadcast;\n      this.data = data;\n    }\n\n    // This broadcast does nothing if this.silenceBroadcast is true.\n    this.broadcastWatches();\n  }\n\n  public recordOptimisticTransaction(\n    transaction: Transaction<NormalizedCacheObject>,\n    id: string,\n  ) {\n    return this.performTransaction(transaction, id);\n  }\n\n  public transformDocument(document: DocumentNode): DocumentNode {\n    if (this.addTypename) {\n      let result = this.typenameDocumentCache.get(document);\n      if (!result) {\n        result = addTypenameToDocument(document);\n        this.typenameDocumentCache.set(document, result);\n        // If someone calls transformDocument and then mistakenly passes the\n        // result back into an API that also calls transformDocument, make sure\n        // we don't keep creating new query documents.\n        this.typenameDocumentCache.set(result, result);\n      }\n      return result;\n    }\n    return document;\n  }\n\n  protected broadcastWatches() {\n    if (!this.silenceBroadcast) {\n      this.watches.forEach(c => this.maybeBroadcastWatch(c));\n    }\n  }\n\n  // This method is wrapped in the constructor so that it will be called only\n  // if the data that would be broadcast has changed.\n  private maybeBroadcastWatch(c: Cache.WatchOptions) {\n    c.callback(\n      this.diff({\n        query: c.query,\n        variables: c.variables,\n        previousResult: c.previousResult && c.previousResult(),\n        optimistic: c.optimistic,\n      }),\n    );\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}