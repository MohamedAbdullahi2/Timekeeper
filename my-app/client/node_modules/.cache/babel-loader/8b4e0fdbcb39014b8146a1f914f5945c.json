{"ast":null,"code":"import objectValues from '../polyfills/objectValues';\nimport keyMap from '../jsutils/keyMap';\nimport inspect from '../jsutils/inspect';\nimport invariant from '../jsutils/invariant';\nimport devAssert from '../jsutils/devAssert';\nimport keyValMap from '../jsutils/keyValMap';\nimport { Kind } from '../language/kinds';\nimport { TokenKind } from '../language/tokenKind';\nimport { parse } from '../language/parser';\nimport { isTypeDefinitionNode } from '../language/predicates';\nimport { dedentBlockStringValue } from '../language/blockString';\nimport { assertValidSDL } from '../validation/validate';\nimport { getDirectiveValues } from '../execution/values';\nimport { specifiedScalarTypes } from '../type/scalars';\nimport { introspectionTypes } from '../type/introspection';\nimport { GraphQLSchema } from '../type/schema';\nimport { GraphQLDirective, GraphQLSkipDirective, GraphQLIncludeDirective, GraphQLDeprecatedDirective } from '../type/directives';\nimport { GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLList, GraphQLNonNull } from '../type/definition';\nimport { valueFromAST } from './valueFromAST';\n\n/**\n * This takes the ast of a schema document produced by the parse function in\n * src/language/parser.js.\n *\n * If no schema definition is provided, then it will look for types named Query\n * and Mutation.\n *\n * Given that AST it constructs a GraphQLSchema. The resulting schema\n * has no resolve methods, so execution will use default resolvers.\n *\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\nexport function buildASTSchema(documentAST, options) {\n  documentAST && documentAST.kind === Kind.DOCUMENT || devAssert(0, 'Must provide valid Document AST');\n  if (!options || !(options.assumeValid || options.assumeValidSDL)) {\n    assertValidSDL(documentAST);\n  }\n  var schemaDef;\n  var typeDefs = [];\n  var directiveDefs = [];\n  for (var _i2 = 0, _documentAST$definiti2 = documentAST.definitions; _i2 < _documentAST$definiti2.length; _i2++) {\n    var def = _documentAST$definiti2[_i2];\n    if (def.kind === Kind.SCHEMA_DEFINITION) {\n      schemaDef = def;\n    } else if (isTypeDefinitionNode(def)) {\n      typeDefs.push(def);\n    } else if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      directiveDefs.push(def);\n    }\n  }\n  var astBuilder = new ASTDefinitionBuilder(options, function (typeName) {\n    var type = typeMap[typeName];\n    if (type === undefined) {\n      throw new Error(\"Type \\\"\".concat(typeName, \"\\\" not found in document.\"));\n    }\n    return type;\n  });\n  var typeMap = keyByNameNode(typeDefs, function (node) {\n    return astBuilder.buildType(node);\n  });\n  var operationTypes = schemaDef ? getOperationTypes(schemaDef) : {\n    query: 'Query',\n    mutation: 'Mutation',\n    subscription: 'Subscription'\n  };\n  var directives = directiveDefs.map(function (def) {\n    return astBuilder.buildDirective(def);\n  }); // If specified directives were not explicitly declared, add them.\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'skip';\n  })) {\n    directives.push(GraphQLSkipDirective);\n  }\n  if (!directives.some(function (directive) {\n    return directive.name === 'include';\n  })) {\n    directives.push(GraphQLIncludeDirective);\n  }\n  if (!directives.some(function (directive) {\n    return directive.name === 'deprecated';\n  })) {\n    directives.push(GraphQLDeprecatedDirective);\n  }\n  return new GraphQLSchema({\n    // Note: While this could make early assertions to get the correctly\n    // typed values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    query: operationTypes.query ? typeMap[operationTypes.query] : null,\n    mutation: operationTypes.mutation ? typeMap[operationTypes.mutation] : null,\n    subscription: operationTypes.subscription ? typeMap[operationTypes.subscription] : null,\n    types: objectValues(typeMap),\n    directives: directives,\n    astNode: schemaDef,\n    assumeValid: options && options.assumeValid,\n    allowedLegacyNames: options && options.allowedLegacyNames\n  });\n  function getOperationTypes(schema) {\n    var opTypes = {};\n    for (var _i4 = 0, _schema$operationType2 = schema.operationTypes; _i4 < _schema$operationType2.length; _i4++) {\n      var operationType = _schema$operationType2[_i4];\n      opTypes[operationType.operation] = operationType.type.name.value;\n    }\n    return opTypes;\n  }\n}\nvar stdTypeMap = keyMap(specifiedScalarTypes.concat(introspectionTypes), function (type) {\n  return type.name;\n});\nexport var ASTDefinitionBuilder = /*#__PURE__*/\nfunction () {\n  function ASTDefinitionBuilder(options, resolveType) {\n    this._options = options;\n    this._resolveType = resolveType;\n  }\n  var _proto = ASTDefinitionBuilder.prototype;\n  _proto.getNamedType = function getNamedType(node) {\n    var name = node.name.value;\n    return stdTypeMap[name] || this._resolveType(name);\n  };\n  _proto.getWrappedType = function getWrappedType(node) {\n    if (node.kind === Kind.LIST_TYPE) {\n      return new GraphQLList(this.getWrappedType(node.type));\n    }\n    if (node.kind === Kind.NON_NULL_TYPE) {\n      return new GraphQLNonNull(this.getWrappedType(node.type));\n    }\n    return this.getNamedType(node);\n  };\n  _proto.buildDirective = function buildDirective(directive) {\n    var _this = this;\n    var locations = directive.locations.map(function (_ref) {\n      var value = _ref.value;\n      return value;\n    });\n    return new GraphQLDirective({\n      name: directive.name.value,\n      description: getDescription(directive, this._options),\n      locations: locations,\n      isRepeatable: directive.repeatable,\n      args: keyByNameNode(directive.arguments || [], function (arg) {\n        return _this.buildArg(arg);\n      }),\n      astNode: directive\n    });\n  };\n  _proto.buildField = function buildField(field) {\n    var _this2 = this;\n    return {\n      // Note: While this could make assertions to get the correctly typed\n      // value, that would throw immediately while type system validation\n      // with validateSchema() will produce more actionable results.\n      type: this.getWrappedType(field.type),\n      description: getDescription(field, this._options),\n      args: keyByNameNode(field.arguments || [], function (arg) {\n        return _this2.buildArg(arg);\n      }),\n      deprecationReason: getDeprecationReason(field),\n      astNode: field\n    };\n  };\n  _proto.buildArg = function buildArg(value) {\n    // Note: While this could make assertions to get the correctly typed\n    // value, that would throw immediately while type system validation\n    // with validateSchema() will produce more actionable results.\n    var type = this.getWrappedType(value.type);\n    return {\n      type: type,\n      description: getDescription(value, this._options),\n      defaultValue: valueFromAST(value.defaultValue, type),\n      astNode: value\n    };\n  };\n  _proto.buildInputField = function buildInputField(value) {\n    // Note: While this could make assertions to get the correctly typed\n    // value, that would throw immediately while type system validation\n    // with validateSchema() will produce more actionable results.\n    var type = this.getWrappedType(value.type);\n    return {\n      type: type,\n      description: getDescription(value, this._options),\n      defaultValue: valueFromAST(value.defaultValue, type),\n      astNode: value\n    };\n  };\n  _proto.buildEnumValue = function buildEnumValue(value) {\n    return {\n      description: getDescription(value, this._options),\n      deprecationReason: getDeprecationReason(value),\n      astNode: value\n    };\n  };\n  _proto.buildType = function buildType(astNode) {\n    var name = astNode.name.value;\n    if (stdTypeMap[name]) {\n      return stdTypeMap[name];\n    }\n    switch (astNode.kind) {\n      case Kind.OBJECT_TYPE_DEFINITION:\n        return this._makeTypeDef(astNode);\n      case Kind.INTERFACE_TYPE_DEFINITION:\n        return this._makeInterfaceDef(astNode);\n      case Kind.ENUM_TYPE_DEFINITION:\n        return this._makeEnumDef(astNode);\n      case Kind.UNION_TYPE_DEFINITION:\n        return this._makeUnionDef(astNode);\n      case Kind.SCALAR_TYPE_DEFINITION:\n        return this._makeScalarDef(astNode);\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        return this._makeInputObjectDef(astNode);\n    } // Not reachable. All possible type definition nodes have been considered.\n\n    /* istanbul ignore next */\n    invariant(false, 'Unexpected type definition node: ' + inspect(astNode));\n  };\n  _proto._makeTypeDef = function _makeTypeDef(astNode) {\n    var _this3 = this;\n    var interfaceNodes = astNode.interfaces;\n    var fieldNodes = astNode.fields; // Note: While this could make assertions to get the correctly typed\n    // values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n\n    var interfaces = interfaceNodes && interfaceNodes.length > 0 ? function () {\n      return interfaceNodes.map(function (ref) {\n        return _this3.getNamedType(ref);\n      });\n    } : [];\n    var fields = fieldNodes && fieldNodes.length > 0 ? function () {\n      return keyByNameNode(fieldNodes, function (field) {\n        return _this3.buildField(field);\n      });\n    } : Object.create(null);\n    return new GraphQLObjectType({\n      name: astNode.name.value,\n      description: getDescription(astNode, this._options),\n      interfaces: interfaces,\n      fields: fields,\n      astNode: astNode\n    });\n  };\n  _proto._makeInterfaceDef = function _makeInterfaceDef(astNode) {\n    var _this4 = this;\n    var fieldNodes = astNode.fields;\n    var fields = fieldNodes && fieldNodes.length > 0 ? function () {\n      return keyByNameNode(fieldNodes, function (field) {\n        return _this4.buildField(field);\n      });\n    } : Object.create(null);\n    return new GraphQLInterfaceType({\n      name: astNode.name.value,\n      description: getDescription(astNode, this._options),\n      fields: fields,\n      astNode: astNode\n    });\n  };\n  _proto._makeEnumDef = function _makeEnumDef(astNode) {\n    var _this5 = this;\n    var valueNodes = astNode.values || [];\n    return new GraphQLEnumType({\n      name: astNode.name.value,\n      description: getDescription(astNode, this._options),\n      values: keyByNameNode(valueNodes, function (value) {\n        return _this5.buildEnumValue(value);\n      }),\n      astNode: astNode\n    });\n  };\n  _proto._makeUnionDef = function _makeUnionDef(astNode) {\n    var _this6 = this;\n    var typeNodes = astNode.types; // Note: While this could make assertions to get the correctly typed\n    // values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n\n    var types = typeNodes && typeNodes.length > 0 ? function () {\n      return typeNodes.map(function (ref) {\n        return _this6.getNamedType(ref);\n      });\n    } : [];\n    return new GraphQLUnionType({\n      name: astNode.name.value,\n      description: getDescription(astNode, this._options),\n      types: types,\n      astNode: astNode\n    });\n  };\n  _proto._makeScalarDef = function _makeScalarDef(astNode) {\n    return new GraphQLScalarType({\n      name: astNode.name.value,\n      description: getDescription(astNode, this._options),\n      astNode: astNode\n    });\n  };\n  _proto._makeInputObjectDef = function _makeInputObjectDef(def) {\n    var _this7 = this;\n    var fields = def.fields;\n    return new GraphQLInputObjectType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      fields: fields ? function () {\n        return keyByNameNode(fields, function (field) {\n          return _this7.buildInputField(field);\n        });\n      } : Object.create(null),\n      astNode: def\n    });\n  };\n  return ASTDefinitionBuilder;\n}();\nfunction keyByNameNode(list, valFn) {\n  return keyValMap(list, function (_ref2) {\n    var name = _ref2.name;\n    return name.value;\n  }, valFn);\n}\n/**\n * Given a field or enum value node, returns the string value for the\n * deprecation reason.\n */\n\nfunction getDeprecationReason(node) {\n  var deprecated = getDirectiveValues(GraphQLDeprecatedDirective, node);\n  return deprecated && deprecated.reason;\n}\n/**\n * Given an ast node, returns its string description.\n * @deprecated: provided to ease adoption and will be removed in v16.\n *\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\n\nexport function getDescription(node, options) {\n  if (node.description) {\n    return node.description.value;\n  }\n  if (options && options.commentDescriptions) {\n    var rawValue = getLeadingCommentBlock(node);\n    if (rawValue !== undefined) {\n      return dedentBlockStringValue('\\n' + rawValue);\n    }\n  }\n}\nfunction getLeadingCommentBlock(node) {\n  var loc = node.loc;\n  if (!loc) {\n    return;\n  }\n  var comments = [];\n  var token = loc.startToken.prev;\n  while (token && token.kind === TokenKind.COMMENT && token.next && token.prev && token.line + 1 === token.next.line && token.line !== token.prev.line) {\n    var value = String(token.value);\n    comments.push(value);\n    token = token.prev;\n  }\n  return comments.reverse().join('\\n');\n}\n/**\n * A helper function to build a GraphQLSchema directly from a source\n * document.\n */\n\nexport function buildSchema(source, options) {\n  return buildASTSchema(parse(source, options), options);\n}","map":{"version":3,"names":["objectValues","keyMap","inspect","invariant","devAssert","keyValMap","Kind","TokenKind","parse","isTypeDefinitionNode","dedentBlockStringValue","assertValidSDL","getDirectiveValues","specifiedScalarTypes","introspectionTypes","GraphQLSchema","GraphQLDirective","GraphQLSkipDirective","GraphQLIncludeDirective","GraphQLDeprecatedDirective","GraphQLScalarType","GraphQLObjectType","GraphQLInterfaceType","GraphQLUnionType","GraphQLEnumType","GraphQLInputObjectType","GraphQLList","GraphQLNonNull","valueFromAST","buildASTSchema","documentAST","options","kind","DOCUMENT","assumeValid","assumeValidSDL","schemaDef","typeDefs","directiveDefs","_i2","_documentAST$definiti2","definitions","length","def","SCHEMA_DEFINITION","push","DIRECTIVE_DEFINITION","astBuilder","ASTDefinitionBuilder","typeName","type","typeMap","undefined","Error","concat","keyByNameNode","node","buildType","operationTypes","getOperationTypes","query","mutation","subscription","directives","map","buildDirective","some","directive","name","types","astNode","allowedLegacyNames","schema","opTypes","_i4","_schema$operationType2","operationType","operation","value","stdTypeMap","resolveType","_options","_resolveType","_proto","prototype","getNamedType","getWrappedType","LIST_TYPE","NON_NULL_TYPE","_this","locations","_ref","description","getDescription","isRepeatable","repeatable","args","arguments","arg","buildArg","buildField","field","_this2","deprecationReason","getDeprecationReason","defaultValue","buildInputField","buildEnumValue","OBJECT_TYPE_DEFINITION","_makeTypeDef","INTERFACE_TYPE_DEFINITION","_makeInterfaceDef","ENUM_TYPE_DEFINITION","_makeEnumDef","UNION_TYPE_DEFINITION","_makeUnionDef","SCALAR_TYPE_DEFINITION","_makeScalarDef","INPUT_OBJECT_TYPE_DEFINITION","_makeInputObjectDef","_this3","interfaceNodes","interfaces","fieldNodes","fields","ref","Object","create","_this4","_this5","valueNodes","values","_this6","typeNodes","_this7","list","valFn","_ref2","deprecated","reason","commentDescriptions","rawValue","getLeadingCommentBlock","loc","comments","token","startToken","prev","COMMENT","next","line","String","reverse","join","buildSchema","source"],"sources":["/Users/sviatoslav/Documents/Project3/Timekeeper/my-app/client/node_modules/graphql/utilities/buildASTSchema.mjs"],"sourcesContent":["import objectValues from '../polyfills/objectValues';\nimport keyMap from '../jsutils/keyMap';\nimport inspect from '../jsutils/inspect';\nimport invariant from '../jsutils/invariant';\nimport devAssert from '../jsutils/devAssert';\nimport keyValMap from '../jsutils/keyValMap';\nimport { Kind } from '../language/kinds';\nimport { TokenKind } from '../language/tokenKind';\nimport { parse } from '../language/parser';\nimport { isTypeDefinitionNode } from '../language/predicates';\nimport { dedentBlockStringValue } from '../language/blockString';\nimport { assertValidSDL } from '../validation/validate';\nimport { getDirectiveValues } from '../execution/values';\nimport { specifiedScalarTypes } from '../type/scalars';\nimport { introspectionTypes } from '../type/introspection';\nimport { GraphQLSchema } from '../type/schema';\nimport { GraphQLDirective, GraphQLSkipDirective, GraphQLIncludeDirective, GraphQLDeprecatedDirective } from '../type/directives';\nimport { GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLList, GraphQLNonNull } from '../type/definition';\nimport { valueFromAST } from './valueFromAST';\n\n/**\n * This takes the ast of a schema document produced by the parse function in\n * src/language/parser.js.\n *\n * If no schema definition is provided, then it will look for types named Query\n * and Mutation.\n *\n * Given that AST it constructs a GraphQLSchema. The resulting schema\n * has no resolve methods, so execution will use default resolvers.\n *\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\nexport function buildASTSchema(documentAST, options) {\n  documentAST && documentAST.kind === Kind.DOCUMENT || devAssert(0, 'Must provide valid Document AST');\n\n  if (!options || !(options.assumeValid || options.assumeValidSDL)) {\n    assertValidSDL(documentAST);\n  }\n\n  var schemaDef;\n  var typeDefs = [];\n  var directiveDefs = [];\n\n  for (var _i2 = 0, _documentAST$definiti2 = documentAST.definitions; _i2 < _documentAST$definiti2.length; _i2++) {\n    var def = _documentAST$definiti2[_i2];\n\n    if (def.kind === Kind.SCHEMA_DEFINITION) {\n      schemaDef = def;\n    } else if (isTypeDefinitionNode(def)) {\n      typeDefs.push(def);\n    } else if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      directiveDefs.push(def);\n    }\n  }\n\n  var astBuilder = new ASTDefinitionBuilder(options, function (typeName) {\n    var type = typeMap[typeName];\n\n    if (type === undefined) {\n      throw new Error(\"Type \\\"\".concat(typeName, \"\\\" not found in document.\"));\n    }\n\n    return type;\n  });\n  var typeMap = keyByNameNode(typeDefs, function (node) {\n    return astBuilder.buildType(node);\n  });\n  var operationTypes = schemaDef ? getOperationTypes(schemaDef) : {\n    query: 'Query',\n    mutation: 'Mutation',\n    subscription: 'Subscription'\n  };\n  var directives = directiveDefs.map(function (def) {\n    return astBuilder.buildDirective(def);\n  }); // If specified directives were not explicitly declared, add them.\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'skip';\n  })) {\n    directives.push(GraphQLSkipDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'include';\n  })) {\n    directives.push(GraphQLIncludeDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'deprecated';\n  })) {\n    directives.push(GraphQLDeprecatedDirective);\n  }\n\n  return new GraphQLSchema({\n    // Note: While this could make early assertions to get the correctly\n    // typed values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    query: operationTypes.query ? typeMap[operationTypes.query] : null,\n    mutation: operationTypes.mutation ? typeMap[operationTypes.mutation] : null,\n    subscription: operationTypes.subscription ? typeMap[operationTypes.subscription] : null,\n    types: objectValues(typeMap),\n    directives: directives,\n    astNode: schemaDef,\n    assumeValid: options && options.assumeValid,\n    allowedLegacyNames: options && options.allowedLegacyNames\n  });\n\n  function getOperationTypes(schema) {\n    var opTypes = {};\n\n    for (var _i4 = 0, _schema$operationType2 = schema.operationTypes; _i4 < _schema$operationType2.length; _i4++) {\n      var operationType = _schema$operationType2[_i4];\n      opTypes[operationType.operation] = operationType.type.name.value;\n    }\n\n    return opTypes;\n  }\n}\nvar stdTypeMap = keyMap(specifiedScalarTypes.concat(introspectionTypes), function (type) {\n  return type.name;\n});\nexport var ASTDefinitionBuilder =\n/*#__PURE__*/\nfunction () {\n  function ASTDefinitionBuilder(options, resolveType) {\n    this._options = options;\n    this._resolveType = resolveType;\n  }\n\n  var _proto = ASTDefinitionBuilder.prototype;\n\n  _proto.getNamedType = function getNamedType(node) {\n    var name = node.name.value;\n    return stdTypeMap[name] || this._resolveType(name);\n  };\n\n  _proto.getWrappedType = function getWrappedType(node) {\n    if (node.kind === Kind.LIST_TYPE) {\n      return new GraphQLList(this.getWrappedType(node.type));\n    }\n\n    if (node.kind === Kind.NON_NULL_TYPE) {\n      return new GraphQLNonNull(this.getWrappedType(node.type));\n    }\n\n    return this.getNamedType(node);\n  };\n\n  _proto.buildDirective = function buildDirective(directive) {\n    var _this = this;\n\n    var locations = directive.locations.map(function (_ref) {\n      var value = _ref.value;\n      return value;\n    });\n    return new GraphQLDirective({\n      name: directive.name.value,\n      description: getDescription(directive, this._options),\n      locations: locations,\n      isRepeatable: directive.repeatable,\n      args: keyByNameNode(directive.arguments || [], function (arg) {\n        return _this.buildArg(arg);\n      }),\n      astNode: directive\n    });\n  };\n\n  _proto.buildField = function buildField(field) {\n    var _this2 = this;\n\n    return {\n      // Note: While this could make assertions to get the correctly typed\n      // value, that would throw immediately while type system validation\n      // with validateSchema() will produce more actionable results.\n      type: this.getWrappedType(field.type),\n      description: getDescription(field, this._options),\n      args: keyByNameNode(field.arguments || [], function (arg) {\n        return _this2.buildArg(arg);\n      }),\n      deprecationReason: getDeprecationReason(field),\n      astNode: field\n    };\n  };\n\n  _proto.buildArg = function buildArg(value) {\n    // Note: While this could make assertions to get the correctly typed\n    // value, that would throw immediately while type system validation\n    // with validateSchema() will produce more actionable results.\n    var type = this.getWrappedType(value.type);\n    return {\n      type: type,\n      description: getDescription(value, this._options),\n      defaultValue: valueFromAST(value.defaultValue, type),\n      astNode: value\n    };\n  };\n\n  _proto.buildInputField = function buildInputField(value) {\n    // Note: While this could make assertions to get the correctly typed\n    // value, that would throw immediately while type system validation\n    // with validateSchema() will produce more actionable results.\n    var type = this.getWrappedType(value.type);\n    return {\n      type: type,\n      description: getDescription(value, this._options),\n      defaultValue: valueFromAST(value.defaultValue, type),\n      astNode: value\n    };\n  };\n\n  _proto.buildEnumValue = function buildEnumValue(value) {\n    return {\n      description: getDescription(value, this._options),\n      deprecationReason: getDeprecationReason(value),\n      astNode: value\n    };\n  };\n\n  _proto.buildType = function buildType(astNode) {\n    var name = astNode.name.value;\n\n    if (stdTypeMap[name]) {\n      return stdTypeMap[name];\n    }\n\n    switch (astNode.kind) {\n      case Kind.OBJECT_TYPE_DEFINITION:\n        return this._makeTypeDef(astNode);\n\n      case Kind.INTERFACE_TYPE_DEFINITION:\n        return this._makeInterfaceDef(astNode);\n\n      case Kind.ENUM_TYPE_DEFINITION:\n        return this._makeEnumDef(astNode);\n\n      case Kind.UNION_TYPE_DEFINITION:\n        return this._makeUnionDef(astNode);\n\n      case Kind.SCALAR_TYPE_DEFINITION:\n        return this._makeScalarDef(astNode);\n\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        return this._makeInputObjectDef(astNode);\n    } // Not reachable. All possible type definition nodes have been considered.\n\n\n    /* istanbul ignore next */\n    invariant(false, 'Unexpected type definition node: ' + inspect(astNode));\n  };\n\n  _proto._makeTypeDef = function _makeTypeDef(astNode) {\n    var _this3 = this;\n\n    var interfaceNodes = astNode.interfaces;\n    var fieldNodes = astNode.fields; // Note: While this could make assertions to get the correctly typed\n    // values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n\n    var interfaces = interfaceNodes && interfaceNodes.length > 0 ? function () {\n      return interfaceNodes.map(function (ref) {\n        return _this3.getNamedType(ref);\n      });\n    } : [];\n    var fields = fieldNodes && fieldNodes.length > 0 ? function () {\n      return keyByNameNode(fieldNodes, function (field) {\n        return _this3.buildField(field);\n      });\n    } : Object.create(null);\n    return new GraphQLObjectType({\n      name: astNode.name.value,\n      description: getDescription(astNode, this._options),\n      interfaces: interfaces,\n      fields: fields,\n      astNode: astNode\n    });\n  };\n\n  _proto._makeInterfaceDef = function _makeInterfaceDef(astNode) {\n    var _this4 = this;\n\n    var fieldNodes = astNode.fields;\n    var fields = fieldNodes && fieldNodes.length > 0 ? function () {\n      return keyByNameNode(fieldNodes, function (field) {\n        return _this4.buildField(field);\n      });\n    } : Object.create(null);\n    return new GraphQLInterfaceType({\n      name: astNode.name.value,\n      description: getDescription(astNode, this._options),\n      fields: fields,\n      astNode: astNode\n    });\n  };\n\n  _proto._makeEnumDef = function _makeEnumDef(astNode) {\n    var _this5 = this;\n\n    var valueNodes = astNode.values || [];\n    return new GraphQLEnumType({\n      name: astNode.name.value,\n      description: getDescription(astNode, this._options),\n      values: keyByNameNode(valueNodes, function (value) {\n        return _this5.buildEnumValue(value);\n      }),\n      astNode: astNode\n    });\n  };\n\n  _proto._makeUnionDef = function _makeUnionDef(astNode) {\n    var _this6 = this;\n\n    var typeNodes = astNode.types; // Note: While this could make assertions to get the correctly typed\n    // values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n\n    var types = typeNodes && typeNodes.length > 0 ? function () {\n      return typeNodes.map(function (ref) {\n        return _this6.getNamedType(ref);\n      });\n    } : [];\n    return new GraphQLUnionType({\n      name: astNode.name.value,\n      description: getDescription(astNode, this._options),\n      types: types,\n      astNode: astNode\n    });\n  };\n\n  _proto._makeScalarDef = function _makeScalarDef(astNode) {\n    return new GraphQLScalarType({\n      name: astNode.name.value,\n      description: getDescription(astNode, this._options),\n      astNode: astNode\n    });\n  };\n\n  _proto._makeInputObjectDef = function _makeInputObjectDef(def) {\n    var _this7 = this;\n\n    var fields = def.fields;\n    return new GraphQLInputObjectType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      fields: fields ? function () {\n        return keyByNameNode(fields, function (field) {\n          return _this7.buildInputField(field);\n        });\n      } : Object.create(null),\n      astNode: def\n    });\n  };\n\n  return ASTDefinitionBuilder;\n}();\n\nfunction keyByNameNode(list, valFn) {\n  return keyValMap(list, function (_ref2) {\n    var name = _ref2.name;\n    return name.value;\n  }, valFn);\n}\n/**\n * Given a field or enum value node, returns the string value for the\n * deprecation reason.\n */\n\n\nfunction getDeprecationReason(node) {\n  var deprecated = getDirectiveValues(GraphQLDeprecatedDirective, node);\n  return deprecated && deprecated.reason;\n}\n/**\n * Given an ast node, returns its string description.\n * @deprecated: provided to ease adoption and will be removed in v16.\n *\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\n\n\nexport function getDescription(node, options) {\n  if (node.description) {\n    return node.description.value;\n  }\n\n  if (options && options.commentDescriptions) {\n    var rawValue = getLeadingCommentBlock(node);\n\n    if (rawValue !== undefined) {\n      return dedentBlockStringValue('\\n' + rawValue);\n    }\n  }\n}\n\nfunction getLeadingCommentBlock(node) {\n  var loc = node.loc;\n\n  if (!loc) {\n    return;\n  }\n\n  var comments = [];\n  var token = loc.startToken.prev;\n\n  while (token && token.kind === TokenKind.COMMENT && token.next && token.prev && token.line + 1 === token.next.line && token.line !== token.prev.line) {\n    var value = String(token.value);\n    comments.push(value);\n    token = token.prev;\n  }\n\n  return comments.reverse().join('\\n');\n}\n/**\n * A helper function to build a GraphQLSchema directly from a source\n * document.\n */\n\n\nexport function buildSchema(source, options) {\n  return buildASTSchema(parse(source, options), options);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}