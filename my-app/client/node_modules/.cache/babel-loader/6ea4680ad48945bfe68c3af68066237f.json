{"ast":null,"code":"import { GraphQLError } from '../../error/GraphQLError';\nimport { print } from '../../language/printer';\nimport { isCompositeType } from '../../type/definition';\nimport { typeFromAST } from '../../utilities/typeFromAST';\nexport function inlineFragmentOnNonCompositeErrorMessage(type) {\n  return \"Fragment cannot condition on non composite type \\\"\".concat(type, \"\\\".\");\n}\nexport function fragmentOnNonCompositeErrorMessage(fragName, type) {\n  return \"Fragment \\\"\".concat(fragName, \"\\\" cannot condition on non composite type \\\"\").concat(type, \"\\\".\");\n}\n/**\n * Fragments on composite type\n *\n * Fragments use a type condition to determine if they apply, since fragments\n * can only be spread into a composite type (object, interface, or union), the\n * type condition must also be a composite type.\n */\n\nexport function FragmentsOnCompositeTypes(context) {\n  return {\n    InlineFragment: function InlineFragment(node) {\n      var typeCondition = node.typeCondition;\n      if (typeCondition) {\n        var type = typeFromAST(context.getSchema(), typeCondition);\n        if (type && !isCompositeType(type)) {\n          context.reportError(new GraphQLError(inlineFragmentOnNonCompositeErrorMessage(print(typeCondition)), typeCondition));\n        }\n      }\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      var type = typeFromAST(context.getSchema(), node.typeCondition);\n      if (type && !isCompositeType(type)) {\n        context.reportError(new GraphQLError(fragmentOnNonCompositeErrorMessage(node.name.value, print(node.typeCondition)), node.typeCondition));\n      }\n    }\n  };\n}","map":{"version":3,"names":["GraphQLError","print","isCompositeType","typeFromAST","inlineFragmentOnNonCompositeErrorMessage","type","concat","fragmentOnNonCompositeErrorMessage","fragName","FragmentsOnCompositeTypes","context","InlineFragment","node","typeCondition","getSchema","reportError","FragmentDefinition","name","value"],"sources":["/Users/sviatoslav/Documents/Project3/Timekeeper/my-app/client/node_modules/graphql/validation/rules/FragmentsOnCompositeTypes.mjs"],"sourcesContent":["import { GraphQLError } from '../../error/GraphQLError';\nimport { print } from '../../language/printer';\nimport { isCompositeType } from '../../type/definition';\nimport { typeFromAST } from '../../utilities/typeFromAST';\nexport function inlineFragmentOnNonCompositeErrorMessage(type) {\n  return \"Fragment cannot condition on non composite type \\\"\".concat(type, \"\\\".\");\n}\nexport function fragmentOnNonCompositeErrorMessage(fragName, type) {\n  return \"Fragment \\\"\".concat(fragName, \"\\\" cannot condition on non composite type \\\"\").concat(type, \"\\\".\");\n}\n/**\n * Fragments on composite type\n *\n * Fragments use a type condition to determine if they apply, since fragments\n * can only be spread into a composite type (object, interface, or union), the\n * type condition must also be a composite type.\n */\n\nexport function FragmentsOnCompositeTypes(context) {\n  return {\n    InlineFragment: function InlineFragment(node) {\n      var typeCondition = node.typeCondition;\n\n      if (typeCondition) {\n        var type = typeFromAST(context.getSchema(), typeCondition);\n\n        if (type && !isCompositeType(type)) {\n          context.reportError(new GraphQLError(inlineFragmentOnNonCompositeErrorMessage(print(typeCondition)), typeCondition));\n        }\n      }\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      var type = typeFromAST(context.getSchema(), node.typeCondition);\n\n      if (type && !isCompositeType(type)) {\n        context.reportError(new GraphQLError(fragmentOnNonCompositeErrorMessage(node.name.value, print(node.typeCondition)), node.typeCondition));\n      }\n    }\n  };\n}\n"],"mappings":"AAAA,SAASA,YAAY,QAAQ,0BAA0B;AACvD,SAASC,KAAK,QAAQ,wBAAwB;AAC9C,SAASC,eAAe,QAAQ,uBAAuB;AACvD,SAASC,WAAW,QAAQ,6BAA6B;AACzD,OAAO,SAASC,wCAAwCA,CAACC,IAAI,EAAE;EAC7D,OAAO,oDAAoD,CAACC,MAAM,CAACD,IAAI,EAAE,KAAK,CAAC;AACjF;AACA,OAAO,SAASE,kCAAkCA,CAACC,QAAQ,EAAEH,IAAI,EAAE;EACjE,OAAO,aAAa,CAACC,MAAM,CAACE,QAAQ,EAAE,8CAA8C,CAAC,CAACF,MAAM,CAACD,IAAI,EAAE,KAAK,CAAC;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASI,yBAAyBA,CAACC,OAAO,EAAE;EACjD,OAAO;IACLC,cAAc,EAAE,SAASA,cAAcA,CAACC,IAAI,EAAE;MAC5C,IAAIC,aAAa,GAAGD,IAAI,CAACC,aAAa;MAEtC,IAAIA,aAAa,EAAE;QACjB,IAAIR,IAAI,GAAGF,WAAW,CAACO,OAAO,CAACI,SAAS,CAAC,CAAC,EAAED,aAAa,CAAC;QAE1D,IAAIR,IAAI,IAAI,CAACH,eAAe,CAACG,IAAI,CAAC,EAAE;UAClCK,OAAO,CAACK,WAAW,CAAC,IAAIf,YAAY,CAACI,wCAAwC,CAACH,KAAK,CAACY,aAAa,CAAC,CAAC,EAAEA,aAAa,CAAC,CAAC;QACtH;MACF;IACF,CAAC;IACDG,kBAAkB,EAAE,SAASA,kBAAkBA,CAACJ,IAAI,EAAE;MACpD,IAAIP,IAAI,GAAGF,WAAW,CAACO,OAAO,CAACI,SAAS,CAAC,CAAC,EAAEF,IAAI,CAACC,aAAa,CAAC;MAE/D,IAAIR,IAAI,IAAI,CAACH,eAAe,CAACG,IAAI,CAAC,EAAE;QAClCK,OAAO,CAACK,WAAW,CAAC,IAAIf,YAAY,CAACO,kCAAkC,CAACK,IAAI,CAACK,IAAI,CAACC,KAAK,EAAEjB,KAAK,CAACW,IAAI,CAACC,aAAa,CAAC,CAAC,EAAED,IAAI,CAACC,aAAa,CAAC,CAAC;MAC3I;IACF;EACF,CAAC;AACH"},"metadata":{},"sourceType":"module"}