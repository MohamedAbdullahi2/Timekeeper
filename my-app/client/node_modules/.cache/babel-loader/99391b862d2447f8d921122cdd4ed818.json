{"ast":null,"code":"import { isAsyncIterable } from 'iterall';\nimport inspect from '../jsutils/inspect';\nimport { addPath, pathToArray } from '../jsutils/Path';\nimport { GraphQLError } from '../error/GraphQLError';\nimport { locatedError } from '../error/locatedError';\nimport { assertValidExecutionArguments, buildExecutionContext, buildResolveInfo, collectFields, execute, getFieldDef, resolveFieldValueOrError } from '../execution/execute';\nimport { getOperationRootType } from '../utilities/getOperationRootType';\nimport mapAsyncIterator from './mapAsyncIterator';\nexport function subscribe(argsOrSchema, document, rootValue, contextValue, variableValues, operationName, fieldResolver, subscribeFieldResolver) {\n  /* eslint-enable no-redeclare */\n  // Extract arguments from object args if provided.\n  return arguments.length === 1 ? subscribeImpl(argsOrSchema) : subscribeImpl({\n    schema: argsOrSchema,\n    document: document,\n    rootValue: rootValue,\n    contextValue: contextValue,\n    variableValues: variableValues,\n    operationName: operationName,\n    fieldResolver: fieldResolver,\n    subscribeFieldResolver: subscribeFieldResolver\n  });\n}\n/**\n * This function checks if the error is a GraphQLError. If it is, report it as\n * an ExecutionResult, containing only errors and no data. Otherwise treat the\n * error as a system-class error and re-throw it.\n */\n\nfunction reportGraphQLError(error) {\n  if (error instanceof GraphQLError) {\n    return {\n      errors: [error]\n    };\n  }\n  throw error;\n}\nfunction subscribeImpl(args) {\n  var schema = args.schema,\n    document = args.document,\n    rootValue = args.rootValue,\n    contextValue = args.contextValue,\n    variableValues = args.variableValues,\n    operationName = args.operationName,\n    fieldResolver = args.fieldResolver,\n    subscribeFieldResolver = args.subscribeFieldResolver;\n  var sourcePromise = createSourceEventStream(schema, document, rootValue, contextValue, variableValues, operationName, subscribeFieldResolver); // For each payload yielded from a subscription, map it over the normal\n  // GraphQL `execute` function, with `payload` as the rootValue.\n  // This implements the \"MapSourceToResponseEvent\" algorithm described in\n  // the GraphQL specification. The `execute` function provides the\n  // \"ExecuteSubscriptionEvent\" algorithm, as it is nearly identical to the\n  // \"ExecuteQuery\" algorithm, for which `execute` is also used.\n\n  var mapSourceToResponse = function mapSourceToResponse(payload) {\n    return execute(schema, document, payload, contextValue, variableValues, operationName, fieldResolver);\n  }; // Resolve the Source Stream, then map every source value to a\n  // ExecutionResult value as described above.\n\n  return sourcePromise.then(function (resultOrStream) {\n    return (\n      // Note: Flow can't refine isAsyncIterable, so explicit casts are used.\n      isAsyncIterable(resultOrStream) ? mapAsyncIterator(resultOrStream, mapSourceToResponse, reportGraphQLError) : resultOrStream\n    );\n  });\n}\n/**\n * Implements the \"CreateSourceEventStream\" algorithm described in the\n * GraphQL specification, resolving the subscription source event stream.\n *\n * Returns a Promise which resolves to either an AsyncIterable (if successful)\n * or an ExecutionResult (error). The promise will be rejected if the schema or\n * other arguments to this function are invalid, or if the resolved event stream\n * is not an async iterable.\n *\n * If the client-provided arguments to this function do not result in a\n * compliant subscription, a GraphQL Response (ExecutionResult) with\n * descriptive errors and no data will be returned.\n *\n * If the the source stream could not be created due to faulty subscription\n * resolver logic or underlying systems, the promise will resolve to a single\n * ExecutionResult containing `errors` and no `data`.\n *\n * If the operation succeeded, the promise resolves to the AsyncIterable for the\n * event stream returned by the resolver.\n *\n * A Source Event Stream represents a sequence of events, each of which triggers\n * a GraphQL execution for that event.\n *\n * This may be useful when hosting the stateful subscription service in a\n * different process or machine than the stateless GraphQL execution engine,\n * or otherwise separating these two steps. For more on this, see the\n * \"Supporting Subscriptions at Scale\" information in the GraphQL specification.\n */\n\nexport function createSourceEventStream(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver) {\n  // If arguments are missing or incorrectly typed, this is an internal\n  // developer mistake which should throw an early error.\n  assertValidExecutionArguments(schema, document, variableValues);\n  try {\n    // If a valid context cannot be created due to incorrect arguments,\n    // this will throw an error.\n    var exeContext = buildExecutionContext(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver); // Return early errors if execution context failed.\n\n    if (Array.isArray(exeContext)) {\n      return Promise.resolve({\n        errors: exeContext\n      });\n    }\n    var type = getOperationRootType(schema, exeContext.operation);\n    var fields = collectFields(exeContext, type, exeContext.operation.selectionSet, Object.create(null), Object.create(null));\n    var responseNames = Object.keys(fields);\n    var responseName = responseNames[0];\n    var fieldNodes = fields[responseName];\n    var fieldNode = fieldNodes[0];\n    var fieldName = fieldNode.name.value;\n    var fieldDef = getFieldDef(schema, type, fieldName);\n    if (!fieldDef) {\n      throw new GraphQLError(\"The subscription field \\\"\".concat(fieldName, \"\\\" is not defined.\"), fieldNodes);\n    } // Call the `subscribe()` resolver or the default resolver to produce an\n    // AsyncIterable yielding raw payloads.\n\n    var resolveFn = fieldDef.subscribe || exeContext.fieldResolver;\n    var path = addPath(undefined, responseName);\n    var info = buildResolveInfo(exeContext, fieldDef, fieldNodes, type, path); // resolveFieldValueOrError implements the \"ResolveFieldEventStream\"\n    // algorithm from GraphQL specification. It differs from\n    // \"ResolveFieldValue\" due to providing a different `resolveFn`.\n\n    var result = resolveFieldValueOrError(exeContext, fieldDef, fieldNodes, resolveFn, rootValue, info); // Coerce to Promise for easier error handling and consistent return type.\n\n    return Promise.resolve(result).then(function (eventStream) {\n      // If eventStream is an Error, rethrow a located error.\n      if (eventStream instanceof Error) {\n        return {\n          errors: [locatedError(eventStream, fieldNodes, pathToArray(path))]\n        };\n      } // Assert field returned an event stream, otherwise yield an error.\n\n      if (isAsyncIterable(eventStream)) {\n        // Note: isAsyncIterable above ensures this will be correct.\n        return eventStream;\n      }\n      throw new Error('Subscription field must return Async Iterable. Received: ' + inspect(eventStream));\n    });\n  } catch (error) {\n    // As with reportGraphQLError above, if the error is a GraphQLError, report\n    // it as an ExecutionResult; otherwise treat it as a system-class error and\n    // re-throw it.\n    return error instanceof GraphQLError ? Promise.resolve({\n      errors: [error]\n    }) : Promise.reject(error);\n  }\n}","map":{"version":3,"names":["isAsyncIterable","inspect","addPath","pathToArray","GraphQLError","locatedError","assertValidExecutionArguments","buildExecutionContext","buildResolveInfo","collectFields","execute","getFieldDef","resolveFieldValueOrError","getOperationRootType","mapAsyncIterator","subscribe","argsOrSchema","document","rootValue","contextValue","variableValues","operationName","fieldResolver","subscribeFieldResolver","arguments","length","subscribeImpl","schema","reportGraphQLError","error","errors","args","sourcePromise","createSourceEventStream","mapSourceToResponse","payload","then","resultOrStream","exeContext","Array","isArray","Promise","resolve","type","operation","fields","selectionSet","Object","create","responseNames","keys","responseName","fieldNodes","fieldNode","fieldName","name","value","fieldDef","concat","resolveFn","path","undefined","info","result","eventStream","Error","reject"],"sources":["/Users/sviatoslav/Documents/Project3/Timekeeper/my-app/client/node_modules/graphql/subscription/subscribe.mjs"],"sourcesContent":["import { isAsyncIterable } from 'iterall';\nimport inspect from '../jsutils/inspect';\nimport { addPath, pathToArray } from '../jsutils/Path';\nimport { GraphQLError } from '../error/GraphQLError';\nimport { locatedError } from '../error/locatedError';\nimport { assertValidExecutionArguments, buildExecutionContext, buildResolveInfo, collectFields, execute, getFieldDef, resolveFieldValueOrError } from '../execution/execute';\nimport { getOperationRootType } from '../utilities/getOperationRootType';\nimport mapAsyncIterator from './mapAsyncIterator';\nexport function subscribe(argsOrSchema, document, rootValue, contextValue, variableValues, operationName, fieldResolver, subscribeFieldResolver) {\n  /* eslint-enable no-redeclare */\n  // Extract arguments from object args if provided.\n  return arguments.length === 1 ? subscribeImpl(argsOrSchema) : subscribeImpl({\n    schema: argsOrSchema,\n    document: document,\n    rootValue: rootValue,\n    contextValue: contextValue,\n    variableValues: variableValues,\n    operationName: operationName,\n    fieldResolver: fieldResolver,\n    subscribeFieldResolver: subscribeFieldResolver\n  });\n}\n/**\n * This function checks if the error is a GraphQLError. If it is, report it as\n * an ExecutionResult, containing only errors and no data. Otherwise treat the\n * error as a system-class error and re-throw it.\n */\n\nfunction reportGraphQLError(error) {\n  if (error instanceof GraphQLError) {\n    return {\n      errors: [error]\n    };\n  }\n\n  throw error;\n}\n\nfunction subscribeImpl(args) {\n  var schema = args.schema,\n      document = args.document,\n      rootValue = args.rootValue,\n      contextValue = args.contextValue,\n      variableValues = args.variableValues,\n      operationName = args.operationName,\n      fieldResolver = args.fieldResolver,\n      subscribeFieldResolver = args.subscribeFieldResolver;\n  var sourcePromise = createSourceEventStream(schema, document, rootValue, contextValue, variableValues, operationName, subscribeFieldResolver); // For each payload yielded from a subscription, map it over the normal\n  // GraphQL `execute` function, with `payload` as the rootValue.\n  // This implements the \"MapSourceToResponseEvent\" algorithm described in\n  // the GraphQL specification. The `execute` function provides the\n  // \"ExecuteSubscriptionEvent\" algorithm, as it is nearly identical to the\n  // \"ExecuteQuery\" algorithm, for which `execute` is also used.\n\n  var mapSourceToResponse = function mapSourceToResponse(payload) {\n    return execute(schema, document, payload, contextValue, variableValues, operationName, fieldResolver);\n  }; // Resolve the Source Stream, then map every source value to a\n  // ExecutionResult value as described above.\n\n\n  return sourcePromise.then(function (resultOrStream) {\n    return (// Note: Flow can't refine isAsyncIterable, so explicit casts are used.\n      isAsyncIterable(resultOrStream) ? mapAsyncIterator(resultOrStream, mapSourceToResponse, reportGraphQLError) : resultOrStream\n    );\n  });\n}\n/**\n * Implements the \"CreateSourceEventStream\" algorithm described in the\n * GraphQL specification, resolving the subscription source event stream.\n *\n * Returns a Promise which resolves to either an AsyncIterable (if successful)\n * or an ExecutionResult (error). The promise will be rejected if the schema or\n * other arguments to this function are invalid, or if the resolved event stream\n * is not an async iterable.\n *\n * If the client-provided arguments to this function do not result in a\n * compliant subscription, a GraphQL Response (ExecutionResult) with\n * descriptive errors and no data will be returned.\n *\n * If the the source stream could not be created due to faulty subscription\n * resolver logic or underlying systems, the promise will resolve to a single\n * ExecutionResult containing `errors` and no `data`.\n *\n * If the operation succeeded, the promise resolves to the AsyncIterable for the\n * event stream returned by the resolver.\n *\n * A Source Event Stream represents a sequence of events, each of which triggers\n * a GraphQL execution for that event.\n *\n * This may be useful when hosting the stateful subscription service in a\n * different process or machine than the stateless GraphQL execution engine,\n * or otherwise separating these two steps. For more on this, see the\n * \"Supporting Subscriptions at Scale\" information in the GraphQL specification.\n */\n\n\nexport function createSourceEventStream(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver) {\n  // If arguments are missing or incorrectly typed, this is an internal\n  // developer mistake which should throw an early error.\n  assertValidExecutionArguments(schema, document, variableValues);\n\n  try {\n    // If a valid context cannot be created due to incorrect arguments,\n    // this will throw an error.\n    var exeContext = buildExecutionContext(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver); // Return early errors if execution context failed.\n\n    if (Array.isArray(exeContext)) {\n      return Promise.resolve({\n        errors: exeContext\n      });\n    }\n\n    var type = getOperationRootType(schema, exeContext.operation);\n    var fields = collectFields(exeContext, type, exeContext.operation.selectionSet, Object.create(null), Object.create(null));\n    var responseNames = Object.keys(fields);\n    var responseName = responseNames[0];\n    var fieldNodes = fields[responseName];\n    var fieldNode = fieldNodes[0];\n    var fieldName = fieldNode.name.value;\n    var fieldDef = getFieldDef(schema, type, fieldName);\n\n    if (!fieldDef) {\n      throw new GraphQLError(\"The subscription field \\\"\".concat(fieldName, \"\\\" is not defined.\"), fieldNodes);\n    } // Call the `subscribe()` resolver or the default resolver to produce an\n    // AsyncIterable yielding raw payloads.\n\n\n    var resolveFn = fieldDef.subscribe || exeContext.fieldResolver;\n    var path = addPath(undefined, responseName);\n    var info = buildResolveInfo(exeContext, fieldDef, fieldNodes, type, path); // resolveFieldValueOrError implements the \"ResolveFieldEventStream\"\n    // algorithm from GraphQL specification. It differs from\n    // \"ResolveFieldValue\" due to providing a different `resolveFn`.\n\n    var result = resolveFieldValueOrError(exeContext, fieldDef, fieldNodes, resolveFn, rootValue, info); // Coerce to Promise for easier error handling and consistent return type.\n\n    return Promise.resolve(result).then(function (eventStream) {\n      // If eventStream is an Error, rethrow a located error.\n      if (eventStream instanceof Error) {\n        return {\n          errors: [locatedError(eventStream, fieldNodes, pathToArray(path))]\n        };\n      } // Assert field returned an event stream, otherwise yield an error.\n\n\n      if (isAsyncIterable(eventStream)) {\n        // Note: isAsyncIterable above ensures this will be correct.\n        return eventStream;\n      }\n\n      throw new Error('Subscription field must return Async Iterable. Received: ' + inspect(eventStream));\n    });\n  } catch (error) {\n    // As with reportGraphQLError above, if the error is a GraphQLError, report\n    // it as an ExecutionResult; otherwise treat it as a system-class error and\n    // re-throw it.\n    return error instanceof GraphQLError ? Promise.resolve({\n      errors: [error]\n    }) : Promise.reject(error);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}