{"ast":null,"code":"import inspect from '../../jsutils/inspect';\nimport { GraphQLError } from '../../error/GraphQLError';\nimport { isCompositeType } from '../../type/definition';\nimport { typeFromAST } from '../../utilities/typeFromAST';\nimport { doTypesOverlap } from '../../utilities/typeComparators';\nexport function typeIncompatibleSpreadMessage(fragName, parentType, fragType) {\n  return \"Fragment \\\"\".concat(fragName, \"\\\" cannot be spread here as objects of type \\\"\").concat(parentType, \"\\\" can never be of type \\\"\").concat(fragType, \"\\\".\");\n}\nexport function typeIncompatibleAnonSpreadMessage(parentType, fragType) {\n  return \"Fragment cannot be spread here as objects of type \\\"\".concat(parentType, \"\\\" can never be of type \\\"\").concat(fragType, \"\\\".\");\n}\n/**\n * Possible fragment spread\n *\n * A fragment spread is only valid if the type condition could ever possibly\n * be true: if there is a non-empty intersection of the possible parent types,\n * and possible types which pass the type condition.\n */\n\nexport function PossibleFragmentSpreads(context) {\n  return {\n    InlineFragment: function InlineFragment(node) {\n      var fragType = context.getType();\n      var parentType = context.getParentType();\n      if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context.getSchema(), fragType, parentType)) {\n        context.reportError(new GraphQLError(typeIncompatibleAnonSpreadMessage(inspect(parentType), inspect(fragType)), node));\n      }\n    },\n    FragmentSpread: function FragmentSpread(node) {\n      var fragName = node.name.value;\n      var fragType = getFragmentType(context, fragName);\n      var parentType = context.getParentType();\n      if (fragType && parentType && !doTypesOverlap(context.getSchema(), fragType, parentType)) {\n        context.reportError(new GraphQLError(typeIncompatibleSpreadMessage(fragName, inspect(parentType), inspect(fragType)), node));\n      }\n    }\n  };\n}\nfunction getFragmentType(context, name) {\n  var frag = context.getFragment(name);\n  if (frag) {\n    var type = typeFromAST(context.getSchema(), frag.typeCondition);\n    if (isCompositeType(type)) {\n      return type;\n    }\n  }\n}","map":{"version":3,"names":["inspect","GraphQLError","isCompositeType","typeFromAST","doTypesOverlap","typeIncompatibleSpreadMessage","fragName","parentType","fragType","concat","typeIncompatibleAnonSpreadMessage","PossibleFragmentSpreads","context","InlineFragment","node","getType","getParentType","getSchema","reportError","FragmentSpread","name","value","getFragmentType","frag","getFragment","type","typeCondition"],"sources":["/Users/sviatoslav/Documents/Project3/Timekeeper/my-app/client/node_modules/graphql/validation/rules/PossibleFragmentSpreads.mjs"],"sourcesContent":["import inspect from '../../jsutils/inspect';\nimport { GraphQLError } from '../../error/GraphQLError';\nimport { isCompositeType } from '../../type/definition';\nimport { typeFromAST } from '../../utilities/typeFromAST';\nimport { doTypesOverlap } from '../../utilities/typeComparators';\nexport function typeIncompatibleSpreadMessage(fragName, parentType, fragType) {\n  return \"Fragment \\\"\".concat(fragName, \"\\\" cannot be spread here as objects of type \\\"\").concat(parentType, \"\\\" can never be of type \\\"\").concat(fragType, \"\\\".\");\n}\nexport function typeIncompatibleAnonSpreadMessage(parentType, fragType) {\n  return \"Fragment cannot be spread here as objects of type \\\"\".concat(parentType, \"\\\" can never be of type \\\"\").concat(fragType, \"\\\".\");\n}\n/**\n * Possible fragment spread\n *\n * A fragment spread is only valid if the type condition could ever possibly\n * be true: if there is a non-empty intersection of the possible parent types,\n * and possible types which pass the type condition.\n */\n\nexport function PossibleFragmentSpreads(context) {\n  return {\n    InlineFragment: function InlineFragment(node) {\n      var fragType = context.getType();\n      var parentType = context.getParentType();\n\n      if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context.getSchema(), fragType, parentType)) {\n        context.reportError(new GraphQLError(typeIncompatibleAnonSpreadMessage(inspect(parentType), inspect(fragType)), node));\n      }\n    },\n    FragmentSpread: function FragmentSpread(node) {\n      var fragName = node.name.value;\n      var fragType = getFragmentType(context, fragName);\n      var parentType = context.getParentType();\n\n      if (fragType && parentType && !doTypesOverlap(context.getSchema(), fragType, parentType)) {\n        context.reportError(new GraphQLError(typeIncompatibleSpreadMessage(fragName, inspect(parentType), inspect(fragType)), node));\n      }\n    }\n  };\n}\n\nfunction getFragmentType(context, name) {\n  var frag = context.getFragment(name);\n\n  if (frag) {\n    var type = typeFromAST(context.getSchema(), frag.typeCondition);\n\n    if (isCompositeType(type)) {\n      return type;\n    }\n  }\n}\n"],"mappings":"AAAA,OAAOA,OAAO,MAAM,uBAAuB;AAC3C,SAASC,YAAY,QAAQ,0BAA0B;AACvD,SAASC,eAAe,QAAQ,uBAAuB;AACvD,SAASC,WAAW,QAAQ,6BAA6B;AACzD,SAASC,cAAc,QAAQ,iCAAiC;AAChE,OAAO,SAASC,6BAA6BA,CAACC,QAAQ,EAAEC,UAAU,EAAEC,QAAQ,EAAE;EAC5E,OAAO,aAAa,CAACC,MAAM,CAACH,QAAQ,EAAE,gDAAgD,CAAC,CAACG,MAAM,CAACF,UAAU,EAAE,4BAA4B,CAAC,CAACE,MAAM,CAACD,QAAQ,EAAE,KAAK,CAAC;AAClK;AACA,OAAO,SAASE,iCAAiCA,CAACH,UAAU,EAAEC,QAAQ,EAAE;EACtE,OAAO,sDAAsD,CAACC,MAAM,CAACF,UAAU,EAAE,4BAA4B,CAAC,CAACE,MAAM,CAACD,QAAQ,EAAE,KAAK,CAAC;AACxI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASG,uBAAuBA,CAACC,OAAO,EAAE;EAC/C,OAAO;IACLC,cAAc,EAAE,SAASA,cAAcA,CAACC,IAAI,EAAE;MAC5C,IAAIN,QAAQ,GAAGI,OAAO,CAACG,OAAO,CAAC,CAAC;MAChC,IAAIR,UAAU,GAAGK,OAAO,CAACI,aAAa,CAAC,CAAC;MAExC,IAAId,eAAe,CAACM,QAAQ,CAAC,IAAIN,eAAe,CAACK,UAAU,CAAC,IAAI,CAACH,cAAc,CAACQ,OAAO,CAACK,SAAS,CAAC,CAAC,EAAET,QAAQ,EAAED,UAAU,CAAC,EAAE;QAC1HK,OAAO,CAACM,WAAW,CAAC,IAAIjB,YAAY,CAACS,iCAAiC,CAACV,OAAO,CAACO,UAAU,CAAC,EAAEP,OAAO,CAACQ,QAAQ,CAAC,CAAC,EAAEM,IAAI,CAAC,CAAC;MACxH;IACF,CAAC;IACDK,cAAc,EAAE,SAASA,cAAcA,CAACL,IAAI,EAAE;MAC5C,IAAIR,QAAQ,GAAGQ,IAAI,CAACM,IAAI,CAACC,KAAK;MAC9B,IAAIb,QAAQ,GAAGc,eAAe,CAACV,OAAO,EAAEN,QAAQ,CAAC;MACjD,IAAIC,UAAU,GAAGK,OAAO,CAACI,aAAa,CAAC,CAAC;MAExC,IAAIR,QAAQ,IAAID,UAAU,IAAI,CAACH,cAAc,CAACQ,OAAO,CAACK,SAAS,CAAC,CAAC,EAAET,QAAQ,EAAED,UAAU,CAAC,EAAE;QACxFK,OAAO,CAACM,WAAW,CAAC,IAAIjB,YAAY,CAACI,6BAA6B,CAACC,QAAQ,EAAEN,OAAO,CAACO,UAAU,CAAC,EAAEP,OAAO,CAACQ,QAAQ,CAAC,CAAC,EAAEM,IAAI,CAAC,CAAC;MAC9H;IACF;EACF,CAAC;AACH;AAEA,SAASQ,eAAeA,CAACV,OAAO,EAAEQ,IAAI,EAAE;EACtC,IAAIG,IAAI,GAAGX,OAAO,CAACY,WAAW,CAACJ,IAAI,CAAC;EAEpC,IAAIG,IAAI,EAAE;IACR,IAAIE,IAAI,GAAGtB,WAAW,CAACS,OAAO,CAACK,SAAS,CAAC,CAAC,EAAEM,IAAI,CAACG,aAAa,CAAC;IAE/D,IAAIxB,eAAe,CAACuB,IAAI,CAAC,EAAE;MACzB,OAAOA,IAAI;IACb;EACF;AACF"},"metadata":{},"sourceType":"module"}